add SVIP platform

--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/svip/boot_reg.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2012 Lantiq Deutschland GmbH */
+/* Copyright (C) 2018 Intel Corporation */
+
+#ifndef __BOOT_REG_H
+#define __BOOT_REG_H
+
+#define boot_r32(m, reg) ltq_r32(&boot[m]->reg)
+#define boot_w32(m, val, reg) ltq_w32(val, &boot[m]->reg)
+#define boot_w32_mask(m, clear, set, reg) ltq_w32_mask(clear, set, &boot[m]->reg)
+
+/** Boot register structure */
+struct svip_reg_boot {
+	volatile unsigned long  rvec;  /*  0x0000 */
+	volatile unsigned long  nvec;  /*  0x0004 */
+	volatile unsigned long  evec;  /*  0x0008 */
+	volatile unsigned long  cp0_status;  /*  0x000C */
+	volatile unsigned long  cp0_epc;  /*  0x0010 */
+	volatile unsigned long  cp0_eepc;  /*  0x0014 */
+	volatile unsigned long  rcu_sr_size; /* 0x0018 CP0: rcu_sr, CP1: size */
+	volatile unsigned long  cfg_stat;  /*  0x001C */
+};
+
+#endif
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/svip/ebu_reg.h
@@ -0,0 +1,332 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2012 Lantiq Deutschland GmbH */
+/* Copyright (C) 2018 Intel Corporation */
+
+#ifndef __EBU_REG_H
+#define __EBU_REG_H
+
+#define ebu_w32(x, y) 		ltq_w32((x), ltq_ebu_membase + (y))
+#define ebu_r32(x) 		ltq_r32(ltq_ebu_membase + (x))
+#define ebu_w32_mask(clear, set, reg)	\
+	ltq_w32_mask(clear, set, ltq_ebu_membase + (reg))
+
+/** EBU register structure */
+struct svip_reg_ebu {
+	volatile unsigned long  clc;  /*  0x0000 */
+	volatile unsigned long  reserved0;  /*  0x04 */
+	volatile unsigned long  id;  /*  0x0008 */
+	volatile unsigned long  reserved1;  /*  0x0c */
+	volatile unsigned long  con;  /*  0x0010 */
+	volatile unsigned long  reserved2[3];  /*  0x14 */
+	volatile unsigned long  addr_sel_0;  /*  0x0020 */
+	volatile unsigned long  addr_sel_1;  /*  0x0024 */
+	volatile unsigned long  addr_sel_2;  /*  0x0028 */
+	volatile unsigned long  addr_sel_3;  /*  0x002c */
+	volatile unsigned long  reserved3[12];  /*  0x30 */
+	volatile unsigned long  con_0;  /*  0x0060 */
+	volatile unsigned long  con_1;  /*  0x0064 */
+	volatile unsigned long  con_2;  /*  0x0068 */
+	volatile unsigned long  con_3;  /*  0x006c */
+	volatile unsigned long  reserved4[16];  /*  0x70 */
+	volatile unsigned long  nand_con;  /*  0x00B0 */
+	volatile unsigned long  nand_wait;  /*  0x00B4 */
+	volatile unsigned long  nand_ecc0;  /*  0x00B8 */
+	volatile unsigned long  nand_ecc_ac;  /*  0x00BC */
+};
+
+/*******************************************************************************
+ * EBU
+ ******************************************************************************/
+#define LTQ_EBU_CLC   0x0000
+#define LTQ_EBU_ID   0x0008
+#define LTQ_EBU_CON   0x0010
+#define LTQ_EBU_ADDR_SEL_0   0x0020
+#define LTQ_EBU_ADDR_SEL_1   0x0024
+#define LTQ_EBU_ADDR_SEL_2   0x0028
+#define LTQ_EBU_ADDR_SEL_3   0x002c
+#define LTQ_EBU_CON_0   0x0060
+#define LTQ_EBU_CON_1   0x0064
+#define LTQ_EBU_CON_2   0x0068
+#define LTQ_EBU_CON_3   0x006c
+#define LTQ_EBU_NAND_CON   0x00B0
+#define LTQ_EBU_NAND_WAIT   0x00B4
+#define LTQ_EBU_NAND_ECC0   0x00B8
+#define LTQ_EBU_NAND_ECC_AC   0x00BC
+
+/*******************************************************************************
+ * EBU Clock Control Register
+ ******************************************************************************/
+
+/* EBU Disable Status Bit (1) */
+#define LTQ_EBU_CLC_DISS   (0x1 << 1)
+#define LTQ_EBU_CLC_DISS_GET(val)   ((((val) & LTQ_EBU_CLC_DISS) >> 1) & 0x1)
+/* Used for Enable/disable Control of the EBU (0) */
+#define LTQ_EBU_CLC_DISR   (0x1)
+#define LTQ_EBU_CLC_DISR_VAL(val)   (((val) & 0x1) << 0)
+#define LTQ_EBU_CLC_DISR_GET(val)   ((((val) & LTQ_EBU_CLC_DISR) >> 0) & 0x1)
+#define LTQ_EBU_CLC_DISR_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CLC_DISR) | (((val) & 0x1) << 0))
+
+/*******************************************************************************
+ * EBU Identification Register (Internal)
+ ******************************************************************************/
+
+/* Module Number (31:8) */
+#define LTQ_EBU_ID_MODNUM   (0xffffff << 8)
+#define LTQ_EBU_ID_MODNUM_GET(val)   ((((val) & LTQ_EBU_ID_MODNUM) >> 8) & 0xffffff)
+/* Revision Number (7:0) */
+#define LTQ_EBU_ID_REVNUM   (0xff)
+#define LTQ_EBU_ID_REVNUM_GET(val)   ((((val) & LTQ_EBU_ID_REVNUM) >> 0) & 0xff)
+
+/*******************************************************************************
+ * External Bus Unit Control Register
+ ******************************************************************************/
+
+/* Driver Turn-Around Control, Chip Select Triggered (22:20) */
+#define LTQ_EBU_CON_DTACS   (0x7 << 20)
+#define LTQ_EBU_CON_DTACS_VAL(val)   (((val) & 0x7) << 20)
+#define LTQ_EBU_CON_DTACS_GET(val)   ((((val) & LTQ_EBU_CON_DTACS) >> 20) & 0x7)
+#define LTQ_EBU_CON_DTACS_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_DTACS) | (((val) & 0x7) << 20))
+/* Driver Turn-Around Control, Read-write Triggered (18:16) */
+#define LTQ_EBU_CON_DTARW   (0x7 << 16)
+#define LTQ_EBU_CON_DTARW_VAL(val)   (((val) & 0x7) << 16)
+#define LTQ_EBU_CON_DTARW_GET(val)   ((((val) & LTQ_EBU_CON_DTARW) >> 16) & 0x7)
+#define LTQ_EBU_CON_DTARW_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_DTARW) | (((val) & 0x7) << 16))
+/* Time-Out Control (15:8) */
+#define LTQ_EBU_CON_TOUTC   (0xff << 8)
+#define LTQ_EBU_CON_TOUTC_VAL(val)   (((val) & 0xff) << 8)
+#define LTQ_EBU_CON_TOUTC_GET(val)   ((((val) & LTQ_EBU_CON_TOUTC) >> 8) & 0xff)
+#define LTQ_EBU_CON_TOUTC_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_TOUTC) | (((val) & 0xff) << 8))
+/* Arbitration Mode (7:6) */
+#define LTQ_EBU_CON_ARBMODE   (0x3 << 6)
+#define LTQ_EBU_CON_ARBMODE_VAL(val)   (((val) & 0x3) << 6)
+#define LTQ_EBU_CON_ARBMODE_GET(val)   ((((val) & LTQ_EBU_CON_ARBMODE) >> 6) & 0x3)
+#define LTQ_EBU_CON_ARBMODE_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_ARBMODE) | (((val) & 0x3) << 6))
+/* Arbitration Synchronization (5) */
+#define LTQ_EBU_CON_ARBSYNC   (0x1 << 5)
+#define LTQ_EBU_CON_ARBSYNC_VAL(val)   (((val) & 0x1) << 5)
+#define LTQ_EBU_CON_ARBSYNC_GET(val)   ((((val) & LTQ_EBU_CON_ARBSYNC) >> 5) & 0x1)
+#define LTQ_EBU_CON_ARBSYNC_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_ARBSYNC) | (((val) & 0x1) << 5))
+
+/*******************************************************************************
+ * Address Select Registers
+ ******************************************************************************/
+
+/* Memory Region Base Address (31:12) */
+#define LTQ_EBU_ADDR_SEL_0_BASE   (0xfffff << 12)
+#define LTQ_EBU_ADDR_SEL_0_BASE_VAL(val)   (((val) & 0xfffff) << 12)
+#define LTQ_EBU_ADDR_SEL_0_BASE_GET(val)   ((((val) & LTQ_EBU_ADDR_SEL_0_BASE) >> 12) & 0xfffff)
+#define LTQ_EBU_ADDR_SEL_0_BASE_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_ADDR_SEL_0_BASE) | (((val) & 0xfffff) << 12))
+/* Memory Region Address Mask (7:4) */
+#define LTQ_EBU_ADDR_SEL_0_MASK   (0xf << 4)
+#define LTQ_EBU_ADDR_SEL_0_MASK_VAL(val)   (((val) & 0xf) << 4)
+#define LTQ_EBU_ADDR_SEL_0_MASK_GET(val)   ((((val) & LTQ_EBU_ADDR_SEL_0_MASK) >> 4) & 0xf)
+#define LTQ_EBU_ADDR_SEL_0_MASK_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_ADDR_SEL_0_MASK) | (((val) & 0xf) << 4))
+/* Memory Region Mirror Enable Control (1) */
+#define LTQ_EBU_ADDR_SEL_0_MRME   (0x1 << 1)
+#define LTQ_EBU_ADDR_SEL_0_MRME_VAL(val)   (((val) & 0x1) << 1)
+#define LTQ_EBU_ADDR_SEL_0_MRME_GET(val)   ((((val) & LTQ_EBU_ADDR_SEL_0_MRME) >> 1) & 0x1)
+#define LTQ_EBU_ADDR_SEL_0_MRME_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_ADDR_SEL_0_MRME) | (((val) & 0x1) << 1))
+/* Memory Region Enable Control (0) */
+#define LTQ_EBU_ADDR_SEL_0_REGEN   (0x1)
+#define LTQ_EBU_ADDR_SEL_0_REGEN_VAL(val)   (((val) & 0x1) << 0)
+#define LTQ_EBU_ADDR_SEL_0_REGEN_GET(val)   ((((val) & LTQ_EBU_ADDR_SEL_0_REGEN) >> 0) & 0x1)
+#define LTQ_EBU_ADDR_SEL_0_REGEN_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_ADDR_SEL_0_REGEN) | (((val) & 0x1) << 0))
+
+/*******************************************************************************
+ * Bus Configuration Registers
+ ******************************************************************************/
+
+/* Memory Region Write Protection (31) */
+#define LTQ_EBU_CON_0_WRDIS   (0x1 << 31)
+#define LTQ_EBU_CON_0_WRDIS_VAL(val)   (((val) & 0x1) << 31)
+#define LTQ_EBU_CON_0_WRDIS_GET(val)   ((((val) & LTQ_EBU_CON_0_WRDIS) >> 31) & 0x1)
+#define LTQ_EBU_CON_0_WRDIS_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_0_WRDIS) | (((val) & 0x1) << 31))
+/* Address Swapping (30) */
+#define LTQ_EBU_CON_0_ADSWP   (0x1 << 30)
+#define LTQ_EBU_CON_0_ADSWP_VAL(val)   (((val) & 0x1) << 30)
+#define LTQ_EBU_CON_0_ADSWP_GET(val)   ((((val) & LTQ_EBU_CON_0_ADSWP) >> 30) & 0x1)
+#define LTQ_EBU_CON_0_ADSWP_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_0_ADSWP) | (((val) & 0x1) << 30))
+/* Address Generation Control (26:24) */
+#define LTQ_EBU_CON_0_AGEN   (0x7 << 24)
+#define LTQ_EBU_CON_0_AGEN_VAL(val)   (((val) & 0x7) << 24)
+#define LTQ_EBU_CON_0_AGEN_GET(val)   ((((val) & LTQ_EBU_CON_0_AGEN) >> 24) & 0x7)
+#define LTQ_EBU_CON_0_AGEN_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_0_AGEN) | (((val) & 0x7) << 24))
+/* Extended Address Setup Control (22) */
+#define LTQ_EBU_CON_0_SETUP   (0x1 << 22)
+#define LTQ_EBU_CON_0_SETUP_VAL(val)   (((val) & 0x1) << 22)
+#define LTQ_EBU_CON_0_SETUP_GET(val)   ((((val) & LTQ_EBU_CON_0_SETUP) >> 22) & 0x1)
+#define LTQ_EBU_CON_0_SETUP_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_0_SETUP) | (((val) & 0x1) << 22))
+/* Variable Wait-State Insertion Control (21:20) */
+#define LTQ_EBU_CON_0_WAIT   (0x3 << 20)
+#define LTQ_EBU_CON_0_WAIT_VAL(val)   (((val) & 0x3) << 20)
+#define LTQ_EBU_CON_0_WAIT_GET(val)   ((((val) & LTQ_EBU_CON_0_WAIT) >> 20) & 0x3)
+#define LTQ_EBU_CON_0_WAIT_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_0_WAIT) | (((val) & 0x3) << 20))
+/* Active WAIT Level Control (19) */
+#define LTQ_EBU_CON_0_WINV   (0x1 << 19)
+#define LTQ_EBU_CON_0_WINV_VAL(val)   (((val) & 0x1) << 19)
+#define LTQ_EBU_CON_0_WINV_GET(val)   ((((val) & LTQ_EBU_CON_0_WINV) >> 19) & 0x1)
+#define LTQ_EBU_CON_0_WINV_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_0_WINV) | (((val) & 0x1) << 19))
+/* External Device Data Width Control (17:16) */
+#define LTQ_EBU_CON_0_PW   (0x3 << 16)
+#define LTQ_EBU_CON_0_PW_VAL(val)   (((val) & 0x3) << 16)
+#define LTQ_EBU_CON_0_PW_GET(val)   ((((val) & LTQ_EBU_CON_0_PW) >> 16) & 0x3)
+#define LTQ_EBU_CON_0_PW_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_0_PW) | (((val) & 0x3) << 16))
+/* Address Latch Enable ALE Duration Control (15:14) */
+#define LTQ_EBU_CON_0_ALEC   (0x3 << 14)
+#define LTQ_EBU_CON_0_ALEC_VAL(val)   (((val) & 0x3) << 14)
+#define LTQ_EBU_CON_0_ALEC_GET(val)   ((((val) & LTQ_EBU_CON_0_ALEC) >> 14) & 0x3)
+#define LTQ_EBU_CON_0_ALEC_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_0_ALEC) | (((val) & 0x3) << 14))
+/* Byte Control Signal Timing Mode Control (13:12) */
+#define LTQ_EBU_CON_0_BCGEN   (0x3 << 12)
+#define LTQ_EBU_CON_0_BCGEN_VAL(val)   (((val) & 0x3) << 12)
+#define LTQ_EBU_CON_0_BCGEN_GET(val)   ((((val) & LTQ_EBU_CON_0_BCGEN) >> 12) & 0x3)
+#define LTQ_EBU_CON_0_BCGEN_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_0_BCGEN) | (((val) & 0x3) << 12))
+/* Write Access Wait-State Control (10:8) */
+#define LTQ_EBU_CON_0_WAITWRC   (0x7 << 8)
+#define LTQ_EBU_CON_0_WAITWRC_VAL(val)   (((val) & 0x7) << 8)
+#define LTQ_EBU_CON_0_WAITWRC_GET(val)   ((((val) & LTQ_EBU_CON_0_WAITWRC) >> 8) & 0x7)
+#define LTQ_EBU_CON_0_WAITWRC_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_0_WAITWRC) | (((val) & 0x7) << 8))
+/* Read Access Wait-State Control (7:6) */
+#define LTQ_EBU_CON_0_WAITRDC   (0x3 << 6)
+#define LTQ_EBU_CON_0_WAITRDC_VAL(val)   (((val) & 0x3) << 6)
+#define LTQ_EBU_CON_0_WAITRDC_GET(val)   ((((val) & LTQ_EBU_CON_0_WAITRDC) >> 6) & 0x3)
+#define LTQ_EBU_CON_0_WAITRDC_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_0_WAITRDC) | (((val) & 0x3) << 6))
+/* Hold/Pause Cycle Control (5:4) */
+#define LTQ_EBU_CON_0_HOLDC   (0x3 << 4)
+#define LTQ_EBU_CON_0_HOLDC_VAL(val)   (((val) & 0x3) << 4)
+#define LTQ_EBU_CON_0_HOLDC_GET(val)   ((((val) & LTQ_EBU_CON_0_HOLDC) >> 4) & 0x3)
+#define LTQ_EBU_CON_0_HOLDC_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_0_HOLDC) | (((val) & 0x3) << 4))
+/* Recovery Cycle Control (3:2) */
+#define LTQ_EBU_CON_0_RECOVC   (0x3 << 2)
+#define LTQ_EBU_CON_0_RECOVC_VAL(val)   (((val) & 0x3) << 2)
+#define LTQ_EBU_CON_0_RECOVC_GET(val)   ((((val) & LTQ_EBU_CON_0_RECOVC) >> 2) & 0x3)
+#define LTQ_EBU_CON_0_RECOVC_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_0_RECOVC) | (((val) & 0x3) << 2))
+/* Wait Cycle Multiplier Control (1:0) */
+#define LTQ_EBU_CON_0_CMULT   (0x3)
+#define LTQ_EBU_CON_0_CMULT_VAL(val)   (((val) & 0x3) << 0)
+#define LTQ_EBU_CON_0_CMULT_GET(val)   ((((val) & LTQ_EBU_CON_0_CMULT) >> 0) & 0x3)
+#define LTQ_EBU_CON_0_CMULT_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_CON_0_CMULT) | (((val) & 0x3) << 0))
+
+
+/*******************************************************************************
+ * NAND Flash Control Register
+ ******************************************************************************/
+
+/* ECC Enabling (31) */
+#define LTQ_EBU_NAND_CON_ECC_ON   (0x1 << 31)
+#define LTQ_EBU_NAND_CON_ECC_ON_VAL(val)   (((val) & 0x1) << 31)
+#define LTQ_EBU_NAND_CON_ECC_ON_GET(val)   ((((val) & LTQ_EBU_NAND_CON_ECC_ON) >> 31) & 0x1)
+#define LTQ_EBU_NAND_CON_ECC_ON_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_NAND_CON_ECC_ON) | (((val) & 0x1) << 31))
+/* Latch enable (23:18) */
+#define LTQ_EBU_NAND_CON_LAT_EN   (0x3f << 18)
+#define LTQ_EBU_NAND_CON_LAT_EN_VAL(val)   (((val) & 0x3f) << 18)
+#define LTQ_EBU_NAND_CON_LAT_EN_GET(val)   ((((val) & LTQ_EBU_NAND_CON_LAT_EN) >> 18) & 0x3f)
+#define LTQ_EBU_NAND_CON_LAT_EN_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_NAND_CON_LAT_EN) | (((val) & 0x3f) << 18))
+/* Output ChipSelect# Selection (11:10) */
+#define LTQ_EBU_NAND_CON_OUT_CS_S   (0x3 << 10)
+#define LTQ_EBU_NAND_CON_OUT_CS_S_VAL(val)   (((val) & 0x3) << 10)
+#define LTQ_EBU_NAND_CON_OUT_CS_S_GET(val)   ((((val) & LTQ_EBU_NAND_CON_OUT_CS_S) >> 10) & 0x3)
+#define LTQ_EBU_NAND_CON_OUT_CS_S_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_NAND_CON_OUT_CS_S) | (((val) & 0x3) << 10))
+/* Input ChipSelect# Selection (9:8) */
+#define LTQ_EBU_NAND_CON_IN_CS_S   (0x3 << 8)
+#define LTQ_EBU_NAND_CON_IN_CS_S_VAL(val)   (((val) & 0x3) << 8)
+#define LTQ_EBU_NAND_CON_IN_CS_S_GET(val)   ((((val) & LTQ_EBU_NAND_CON_IN_CS_S) >> 8) & 0x3)
+#define LTQ_EBU_NAND_CON_IN_CS_S_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_NAND_CON_IN_CS_S) | (((val) & 0x3) << 8))
+/* Set PRE (7) */
+#define LTQ_EBU_NAND_CON_PRE_P   (0x1 << 7)
+#define LTQ_EBU_NAND_CON_PRE_P_VAL(val)   (((val) & 0x1) << 7)
+#define LTQ_EBU_NAND_CON_PRE_P_GET(val)   ((((val) & LTQ_EBU_NAND_CON_PRE_P) >> 7) & 0x1)
+#define LTQ_EBU_NAND_CON_PRE_P_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_NAND_CON_PRE_P) | (((val) & 0x1) << 7))
+/* Set WP Active Polarity (6) */
+#define LTQ_EBU_NAND_CON_WP_P   (0x1 << 6)
+#define LTQ_EBU_NAND_CON_WP_P_VAL(val)   (((val) & 0x1) << 6)
+#define LTQ_EBU_NAND_CON_WP_P_GET(val)   ((((val) & LTQ_EBU_NAND_CON_WP_P) >> 6) & 0x1)
+#define LTQ_EBU_NAND_CON_WP_P_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_NAND_CON_WP_P) | (((val) & 0x1) << 6))
+/* Set SE Active Polarity (5) */
+#define LTQ_EBU_NAND_CON_SE_P   (0x1 << 5)
+#define LTQ_EBU_NAND_CON_SE_P_VAL(val)   (((val) & 0x1) << 5)
+#define LTQ_EBU_NAND_CON_SE_P_GET(val)   ((((val) & LTQ_EBU_NAND_CON_SE_P) >> 5) & 0x1)
+#define LTQ_EBU_NAND_CON_SE_P_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_NAND_CON_SE_P) | (((val) & 0x1) << 5))
+/* Set CS Active Polarity (4) */
+#define LTQ_EBU_NAND_CON_CS_P   (0x1 << 4)
+#define LTQ_EBU_NAND_CON_CS_P_VAL(val)   (((val) & 0x1) << 4)
+#define LTQ_EBU_NAND_CON_CS_P_GET(val)   ((((val) & LTQ_EBU_NAND_CON_CS_P) >> 4) & 0x1)
+#define LTQ_EBU_NAND_CON_CS_P_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_NAND_CON_CS_P) | (((val) & 0x1) << 4))
+/* Set CLE Active Polarity (3) */
+#define LTQ_EBU_NAND_CON_CLE_P   (0x1 << 3)
+#define LTQ_EBU_NAND_CON_CLE_P_VAL(val)   (((val) & 0x1) << 3)
+#define LTQ_EBU_NAND_CON_CLE_P_GET(val)   ((((val) & LTQ_EBU_NAND_CON_CLE_P) >> 3) & 0x1)
+#define LTQ_EBU_NAND_CON_CLE_P_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_NAND_CON_CLE_P) | (((val) & 0x1) << 3))
+/* Set ALE Active Polarity (2) */
+#define LTQ_EBU_NAND_CON_ALE_P   (0x1 << 2)
+#define LTQ_EBU_NAND_CON_ALE_P_VAL(val)   (((val) & 0x1) << 2)
+#define LTQ_EBU_NAND_CON_ALE_P_GET(val)   ((((val) & LTQ_EBU_NAND_CON_ALE_P) >> 2) & 0x1)
+#define LTQ_EBU_NAND_CON_ALE_P_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_NAND_CON_ALE_P) | (((val) & 0x1) << 2))
+/* NAND CS Mux with EBU CS Enable (1) */
+#define LTQ_EBU_NAND_CON_CSMUX_E   (0x1 << 1)
+#define LTQ_EBU_NAND_CON_CSMUX_E_VAL(val)   (((val) & 0x1) << 1)
+#define LTQ_EBU_NAND_CON_CSMUX_E_GET(val)   ((((val) & LTQ_EBU_NAND_CON_CSMUX_E) >> 1) & 0x1)
+#define LTQ_EBU_NAND_CON_CSMUX_E_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_NAND_CON_CSMUX_E) | (((val) & 0x1) << 1))
+/* NAND FLASH Mode Support (0) */
+#define LTQ_EBU_NAND_CON_NANDMODE   (0x1)
+#define LTQ_EBU_NAND_CON_NANDMODE_VAL(val)   (((val) & 0x1) << 0)
+#define LTQ_EBU_NAND_CON_NANDMODE_GET(val)   ((((val) & LTQ_EBU_NAND_CON_NANDMODE) >> 0) & 0x1)
+#define LTQ_EBU_NAND_CON_NANDMODE_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_NAND_CON_NANDMODE) | (((val) & 0x1) << 0))
+
+/*******************************************************************************
+ * NAND Flash State Register
+ ******************************************************************************/
+
+/* Reserved (31:3) */
+#define LTQ_EBU_NAND_WAIT_RES   (0x1fffffff << 3)
+#define LTQ_EBU_NAND_WAIT_RES_GET(val)   ((((val) & LTQ_EBU_NAND_WAIT_RES) >> 3) & 0x1fffffff)
+/* NAND Write Complete (3) */
+#define LTQ_EBU_NAND_WAIT_WR_C   (0x1 << 3)
+#define LTQ_EBU_NAND_WAIT_WR_C_GET(val)   ((((val) & LTQ_EBU_NAND_WAIT_WR_C) >> 3) & 0x1)
+/* Record the RD Edge (rising ) (2) */
+#define LTQ_EBU_NAND_WAIT_RD_EDGE   (0x1 << 2)
+#define LTQ_EBU_NAND_WAIT_RD_EDGE_GET(val)   ((((val) & LTQ_EBU_NAND_WAIT_RD_EDGE) >> 2) & 0x1)
+/* Record the BY# Edge (falling) (1) */
+#define LTQ_EBU_NAND_WAIT_BY_EDGE   (0x1 << 1)
+#define LTQ_EBU_NAND_WAIT_BY_EDGE_GET(val)   ((((val) & LTQ_EBU_NAND_WAIT_BY_EDGE) >> 1) & 0x1)
+/* Rd/BY# value (0) */
+#define LTQ_EBU_NAND_WAIT_RDBY_VALUE   (0x1)
+#define LTQ_EBU_NAND_WAIT_RDBY_VALUE_GET(val)   ((((val) & LTQ_EBU_NAND_WAIT_RDBY_VALUE) >> 0) & 0x1)
+
+/*******************************************************************************
+ * NAND ECC Result Register 0
+ ******************************************************************************/
+
+/* Reserved (31:24) */
+#define LTQ_EBU_NAND_ECC0_RES   (0xff << 24)
+#define LTQ_EBU_NAND_ECC0_RES_GET(val)   ((((val) & LTQ_EBU_NAND_ECC0_RES) >> 24) & 0xff)
+/* ECC value (23:16) */
+#define LTQ_EBU_NAND_ECC0_ECC_B2   (0xff << 16)
+#define LTQ_EBU_NAND_ECC0_ECC_B2_VAL(val)   (((val) & 0xff) << 16)
+#define LTQ_EBU_NAND_ECC0_ECC_B2_GET(val)   ((((val) & LTQ_EBU_NAND_ECC0_ECC_B2) >> 16) & 0xff)
+#define LTQ_EBU_NAND_ECC0_ECC_B2_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_NAND_ECC0_ECC_B2) | (((val) & 0xff) << 16))
+/* ECC value (15:8) */
+#define LTQ_EBU_NAND_ECC0_ECC_B1   (0xff << 8)
+#define LTQ_EBU_NAND_ECC0_ECC_B1_VAL(val)   (((val) & 0xff) << 8)
+#define LTQ_EBU_NAND_ECC0_ECC_B1_GET(val)   ((((val) & LTQ_EBU_NAND_ECC0_ECC_B1) >> 8) & 0xff)
+#define LTQ_EBU_NAND_ECC0_ECC_B1_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_NAND_ECC0_ECC_B1) | (((val) & 0xff) << 8))
+/* ECC value (7:0) */
+#define LTQ_EBU_NAND_ECC0_ECC_B0   (0xff)
+#define LTQ_EBU_NAND_ECC0_ECC_B0_VAL(val)   (((val) & 0xff) << 0)
+#define LTQ_EBU_NAND_ECC0_ECC_B0_GET(val)   ((((val) & LTQ_EBU_NAND_ECC0_ECC_B0) >> 0) & 0xff)
+#define LTQ_EBU_NAND_ECC0_ECC_B0_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_NAND_ECC0_ECC_B0) | (((val) & 0xff) << 0))
+
+/*******************************************************************************
+ * NAND ECC Address Counter Register
+ ******************************************************************************/
+
+/* Reserved (31:9) */
+#define LTQ_EBU_NAND_ECC_AC_RES   (0x7fffff << 9)
+#define LTQ_EBU_NAND_ECC_AC_RES_GET(val)   ((((val) & LTQ_EBU_NAND_ECC_AC_RES) >> 9) & 0x7fffff)
+/* ECC address counter (8:0) */
+#define LTQ_EBU_NAND_ECC_AC_ECC_AC   (0x1ff)
+#define LTQ_EBU_NAND_ECC_AC_ECC_AC_VAL(val)   (((val) & 0x1ff) << 0)
+#define LTQ_EBU_NAND_ECC_AC_ECC_AC_GET(val)   ((((val) & LTQ_EBU_NAND_ECC_AC_ECC_AC) >> 0) & 0x1ff)
+#define LTQ_EBU_NAND_ECC_AC_ECC_AC_SET(reg,val) (reg) = ((reg & ~LTQ_EBU_NAND_ECC_AC_ECC_AC) | (((val) & 0x1ff) << 0))
+
+#endif /* __LTQ_EBU_H */
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/svip/irq.h
@@ -0,0 +1,22 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2010 John Crispin <blogic@openwrt.org> */
+/* Copyright (C) 2018 Intel Corporation */
+
+#ifndef _LANTIQ_LTQ_IRQ_H__
+#define _LANTIQ_LTQ_IRQ_H__
+
+#define NR_IRQS 264
+#define MIPS_CPU_IRQ_BASE 0
+#define INT_NUM_IRQ0		8
+#define INT_NUM_IM0_IRL0	(INT_NUM_IRQ0 + 0)
+#define INT_NUM_IM1_IRL0	(INT_NUM_IRQ0 + 32)
+#define INT_NUM_IM2_IRL0	(INT_NUM_IRQ0 + 64)
+#define INT_NUM_IM3_IRL0	(INT_NUM_IRQ0 + 96)
+#define INT_NUM_IM4_IRL0	(INT_NUM_IRQ0 + 128)
+#define INT_NUM_IM5_IRL0	(INT_NUM_IRQ0 + 160)
+#define INT_NUM_IM_OFFSET	(INT_NUM_IM1_IRL0 - INT_NUM_IM0_IRL0)
+#define LTQ_DMA_CH0_INT		(INT_NUM_IM2_IRL0)
+#define MIPS_CPU_TIMER_IRQ	(INT_NUM_IM5_IRL0 + 2) 
+#define MAX_IM			6
+
+#endif /* _LANTIQ_LTQ_IRQ_H__ */
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/svip/lantiq_soc.h
@@ -0,0 +1,182 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2010 John Crispin <blogic@openwrt.org> */
+/* Copyright (C) 2018 Intel Corporation */
+
+#ifndef _LTQ_SVIP_H__
+#define _LTQ_SVIP_H__
+
+#ifdef CONFIG_SOC_SVIP
+
+#include <linux/pinctrl/pinctrl.h>
+#include <lantiq.h>
+
+/* Chip IDs */
+#define SOC_ID_SVIP		0x169
+#define SOC_ID_SVIPx		0x160
+
+/* SoC Types */
+#define SOC_TYPE_SVIP		0x0A
+
+#define LTQ_EBU_BASE				0x14102000
+#define LTQ_ASC0_BASE_ADDR			0x14100100
+#define LTQ_ASC1_BASE_ADDR			0x14100200
+#define LTQ_STATUS_BASE_ADDR			0x1E000500
+#define LTQ_ES_BASE_ADDR			0x18000000
+#define LTQ_L2_SPRAM_BASE_ADDR			0x1F1E8000
+#define LTQ_MPS_BASE_ADDR			0x1E000100
+
+#define SYS0_PLL1CR			0x0008
+#define SYS0_PLL1CR_PLLDIV		(0x3)
+#define SYS0_PLL1CR_PLLDIV_GET(val)	((((val) & SYS0_PLL1CR_PLLDIV) >> 0) & 0x3)
+#define SYS0_BCR			0x0004
+
+#define SYS1_CLKSR			0x0000
+#define SYS1_CLKENR			0x0004
+#define SYS1_CLKCLR			0x0008
+#define SYS1_L2CCR			0x0010
+#define SYS1_FPICR			0x0014
+#define SYS1_WDTCR			0x0018
+#define SYS1_CPUCR0			0x0020
+#define SYS1_CPUCR1			0x0024
+#define SYS1_CPUCR2			0x0028
+#define SYS1_CPUCR3			0x002C
+#define SYS1_CPUCR4			0x0030
+#define SYS1_CPUCR5			0x0034
+#define SYS1_RSR			0x0040
+#define SYS1_RREQR			0x0044
+#define SYS1_RRLSR			0x0048
+#define SYS1_RBTR			0x004C
+#define SYS1_IRNCR			0x0050
+#define SYS1_IRNICR			0x0054
+#define SYS1_IRNEN			0x0058
+#define SYS1_CPU0RSR			0x0060
+#define SYS1_CPU1RSR			0x0064
+#define SYS1_CPU2RSR			0x0068
+#define SYS1_CPU3RSR			0x006C
+#define SYS1_CPU4RSR			0x0070
+#define SYS1_CPU5RSR			0x0074
+#define SYS1_CPU0SRSSR			0x0080
+#define SYS1_CPU1SRSSR			0x0084
+#define SYS1_CPU2SRSSR			0x0088
+#define SYS1_CPU3SRSSR			0x008C
+#define SYS1_CPU4SRSSR			0x0090
+#define SYS1_CPU5SRSSR			0x0094
+#define SYS1_CPU0WRSSR			0x00A0
+#define SYS1_CPU1WRSSR			0x00A4
+#define SYS1_CPU2WRSSR			0x00A8
+#define SYS1_CPU3WRSSR			0x00AC
+#define SYS1_CPU4WRSSR			0x00B0
+#define SYS1_CPU5WRSSR			0x00B4
+#define SYS1_CLKENR_PORT0		(0x1 << 0)
+#define SYS1_CLKENR_PORT1		(0x1 << 1)
+#define SYS1_CLKENR_PORT2		(0x1 << 2)
+#define SYS1_CLKENR_PORT3		(0x1 << 3)
+#define SYS1_CLKENR_DEU			(0x1 << 4)
+#define SYS1_CLKENR_TRNG		(0x1 << 5)
+#define SYS1_CLKENR_EBU			(0x1 << 6)
+#define SYS1_CLKENR_ETHSW		(0x1 << 7)
+#define SYS1_CLKENR_FSCT		(0x1 << 8)
+#define SYS1_CLKENR_DMA			(0x1 << 9)
+#define SYS1_CLKENR_GPTC		(0x1 << 10)
+#define SYS1_CLKENR_SSC0		(0x1 << 11)
+#define SYS1_CLKENR_SSC1		(0x1 << 12)
+#define SYS1_CLKENR_SSC2		(0x1 << 13)
+#define SYS1_CLKENR_ASC0		(0x1 << 14)
+#define SYS1_CLKENR_ASC1		(0x1 << 15)
+#define SYS1_CLKENR_PCM0		(0x1 << 16)
+#define SYS1_CLKENR_PCM1		(0x1 << 17)
+#define SYS1_CLKENR_PCM2		(0x1 << 18)
+#define SYS1_CLKENR_PCM3		(0x1 << 19)
+#define SYS1_CLKENR_FMI0		(0x1 << 26)
+#define SYS1_CLKENR_SMI0		(0x1 << 27)
+#define SYS1_CLKENR_SMI2		(0x1 << 29)
+#define SYS1_CLKENR_DDR2		(0x1 << 30)
+#define SYS1_CLKENR_L2C			(0x1 << 31)
+#define SYS1_FPICR_FPIDIV		(0x1)
+#define SYS1_FPICR_FPIDIV_GET(val)	((((val) & SYS1_FPICR_FPIDIV) >> 0) & 0x1)
+
+#define SYS2_CLKSR				0x0000
+#define SYS2_CLKENR				0x0004
+#define SYS2_CLKCLR				0x0008
+#define SYS2_RSR				0x0010
+#define SYS2_RREQR				0x0014
+#define SYS2_RRLSR				0x0018
+
+#define FUSE_DEU				0x0000
+#define FUSE_CPU				0x0004
+#define FUSE_PLL				0x0008
+#define STATUS_CHIPID				0x000C
+#define STATUS_CONFIG				0x0010
+#define STATUS_CHIPLOC				0x0014
+#define FUSE_SPARE				0x0018 
+
+#define SVIP_FUSE	((u32 *)(KSEG1 + LTQ_STATUS_BASE_ADDR + FUSE_DEU))
+#define SVIP_CHIPID	((u32 *)(KSEG1 + LTQ_STATUS_BASE_ADDR + STATUS_CHIPID))
+#define SVIP_CHIPTYPE	((u32 *)(KSEG1 + LTQ_STATUS_BASE_ADDR + FUSE_DEU))
+#define SVIP_CHIPCONF	((u32 *)(KSEG1 + LTQ_STATUS_BASE_ADDR + STATUS_CONFIG))
+
+#define STATUS_CHIPID_PART_NUMBER		(0xffff << 12)
+#define STATUS_CHIPID_PART_NUMBER_GET(val)	((((val) & STATUS_CHIPID_PART_NUMBER) >> 12) & 0xffff)
+#define STATUS_CHIPID_VERSION			(0xf << 28)
+#define STATUS_CHIPID_VERSION_GET(val)		((((val) & STATUS_CHIPID_VERSION) >> 28) & 0xf)
+#define STATUS_FUSE_DEU_DEU			(0x1)
+#define STATUS_FUSE_DEU_DEU_GET(val)		((((val) & STATUS_FUSE_DEU_DEU) >> 0) & 0x1)
+#define STATUS_CONFIG_CLK_MODE			(0x1 << 1)
+#define STATUS_CONFIG_CLK_MODE_GET(val)		((((val) & STATUS_CONFIG_CLK_MODE) >> 4) & 0x1) 
+
+/*
+ * during early_printk no ioremap possible at this early stage
+ * lets use KSEG1 instead
+ */
+
+#define LTQ_ASC_SIZE				0x100
+#define LTQ_EARLY_ASC				KSEG1ADDR(LTQ_ASC0_BASE_ADDR)
+
+/* WDT */
+#define LTQ_RST_CAUSE_WDTRST			0x0002
+
+/* SYSCTL - start/stop/restart/configure/... different parts of the Soc */
+#define SYSCTL_SYS0				0
+#define SYSCTL_SYS1				1
+#define SYSCTL_SYS2				2
+#define SYSCTL_STATUS				3
+#define SYSCTL_EBU				4
+
+
+extern void ltq_sysctl_activate(int module, unsigned int mask);
+extern void ltq_sysctl_deactivate(int module, unsigned int mask);
+extern void ltq_sysctl_clken(int module, unsigned int mask);
+extern void ltq_sysctl_clkdis(int module, unsigned int mask);
+extern void ltq_sysctl_reboot(int module, unsigned int mask);
+
+/* BOOT_SEL - find what boot media we have */
+#define BS_FLASH				0x1
+
+
+/* global register ranges */
+extern __iomem void *ltq_ebu_membase;
+extern __iomem void *ltq_sys0_membase;
+extern __iomem void *ltq_sys1_membase;
+#define ltq_ebu_w32(x, y)		ltq_w32((x), ltq_ebu_membase + (y))
+#define ltq_ebu_r32(x)			ltq_r32(ltq_ebu_membase + (x))
+
+#define ltq_sys0_w32(x, y)	ltq_w32((x), ltq_sys0_membase + (y))
+#define ltq_sys0_r32(x)		ltq_r32(ltq_sys0_membase + (x))
+#define ltq_sys0_w32_mask(clear, set, reg) \
+	ltq_sys0_w32((ltq_sys0_r32(reg) & ~(clear)) | (set), reg)
+
+#define ltq_sys1_w32(x, y)	ltq_w32((x), ltq_sys1_membase + (y))
+#define ltq_sys1_r32(x)		ltq_r32(ltq_sys1_membase + (x))
+#define ltq_sys1_w32_mask(clear, set, reg)   \
+	ltq_sys1_w32((ltq_sys1_r32(reg) & ~(clear)) | (set), reg)
+
+extern void ltq_sysctl_chipid_get(unsigned int *chipid);
+
+/*
+ * to keep the irq code generic we need to define this to 0 as SVIP
+ * has no EBU_PCC_ISTAT register
+ */
+#define LTQ_EBU_PCC_ISTAT	0
+
+#endif /* CONFIG_SOC_SVIP */
+#endif /* _LTQ_SVIP_H__ */
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/svip/mps_reg.h
@@ -0,0 +1,200 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2012 Lantiq Deutschland GmbH */
+/* Copyright (C) 2018 Intel Corporation */
+
+#ifndef __MPS_REG_H
+#define __MPS_REG_H
+
+#define mbs_r32(reg) ltq_r32(&mbs->reg)
+#define mbs_w32(val, reg) ltq_w32(val, &mbs->reg)
+#define mbs_w32_mask(clear, set, reg) ltq_w32_mask(clear, set, &mbs->reg)
+
+#define mps_r32(reg) ltq_r32(&mps->reg)
+#define mps_w32(val, reg) ltq_w32(val, &mps->reg)
+#define mps_w32_mask(clear, set, reg) ltq_w32_mask(clear, set, &mps->reg)
+
+/** MBS register structure */
+struct svip_reg_mbs {
+	unsigned long reserved0[4];
+	unsigned long mbsr0; /* 0x0010 */
+	unsigned long mbsr1; /* 0x0014 */
+	unsigned long mbsr2; /* 0x0018 */
+	unsigned long mbsr3; /* 0x001c */
+	unsigned long mbsr4; /* 0x0020 */
+	unsigned long mbsr5; /* 0x0024 */
+	unsigned long mbsr6; /* 0x0028 */
+	unsigned long mbsr7; /* 0x002c */
+	unsigned long mbsr8; /* 0x0030 */
+	unsigned long mbsr9; /* 0x0034 */
+	unsigned long mbsr10; /* 0x0038 */
+	unsigned long mbsr11; /* 0x003c */
+	unsigned long mbsr12; /* 0x0040 */
+	unsigned long mbsr13; /* 0x0044 */
+	unsigned long mbsr14; /* 0x0048 */
+	unsigned long mbsr15; /* 0x004c */
+	unsigned long mbsr16; /* 0x0050 */
+	unsigned long mbsr17; /* 0x0054 */
+	unsigned long mbsr18; /* 0x0058 */
+	unsigned long mbsr19; /* 0x005c */
+	unsigned long mbsr20; /* 0x0060 */
+	unsigned long mbsr21; /* 0x0064 */
+	unsigned long mbsr22; /* 0x0068 */
+	unsigned long mbsr23; /* 0x006c */
+	unsigned long mbsr24; /* 0x0070 */
+	unsigned long mbsr25; /* 0x0074 */
+	unsigned long mbsr26; /* 0x0078 */
+	unsigned long mbsr27; /* 0x007c */
+	unsigned long mbsr28; /* 0x0080 */
+};
+
+/** MPS register structure */
+struct svip_reg_mps {
+	volatile unsigned long  mps_swirn0set;  /*  0x0000 */
+	volatile unsigned long  mps_swirn0en;  /*  0x0004 */
+	volatile unsigned long  mps_swirn0cr;  /*  0x0008 */
+	volatile unsigned long  mps_swirn0icr;  /*  0x000C */
+	volatile unsigned long  mps_swirn1set;  /*  0x0010 */
+	volatile unsigned long  mps_swirn1en;  /*  0x0014 */
+	volatile unsigned long  mps_swirn1cr;  /*  0x0018 */
+	volatile unsigned long  mps_swirn1icr;  /*  0x001C */
+	volatile unsigned long  mps_swirn2set;  /*  0x0020 */
+	volatile unsigned long  mps_swirn2en;  /*  0x0024 */
+	volatile unsigned long  mps_swirn2cr;  /*  0x0028 */
+	volatile unsigned long  mps_swirn2icr;  /*  0x002C */
+	volatile unsigned long  mps_swirn3set;  /*  0x0030 */
+	volatile unsigned long  mps_swirn3en;  /*  0x0034 */
+	volatile unsigned long  mps_swirn3cr;  /*  0x0038 */
+	volatile unsigned long  mps_swirn3icr;  /*  0x003C */
+	volatile unsigned long  mps_swirn4set;  /*  0x0040 */
+	volatile unsigned long  mps_swirn4en;  /*  0x0044 */
+	volatile unsigned long  mps_swirn4cr;  /*  0x0048 */
+	volatile unsigned long  mps_swirn4icr;  /*  0x004C */
+	volatile unsigned long  mps_swirn5set;  /*  0x0050 */
+	volatile unsigned long  mps_swirn5en;  /*  0x0054 */
+	volatile unsigned long  mps_swirn5cr;  /*  0x0058 */
+	volatile unsigned long  mps_swirn5icr;  /*  0x005C */
+	volatile unsigned long  mps_swirn6set;  /*  0x0060 */
+	volatile unsigned long  mps_swirn6en;  /*  0x0064 */
+	volatile unsigned long  mps_swirn6cr;  /*  0x0068 */
+	volatile unsigned long  mps_swirn6icr;  /*  0x006C */
+	volatile unsigned long  mps_swirn7set;  /*  0x0070 */
+	volatile unsigned long  mps_swirn7en;  /*  0x0074 */
+	volatile unsigned long  mps_swirn7cr;  /*  0x0078 */
+	volatile unsigned long  mps_swirn7icr;  /*  0x007C */
+	volatile unsigned long  mps_swirn8set;  /*  0x0080 */
+	volatile unsigned long  mps_swirn8en;  /*  0x0084 */
+	volatile unsigned long  mps_swirn8cr;  /*  0x0088 */
+	volatile unsigned long  mps_swirn8icr;  /*  0x008C */
+};
+
+/*******************************************************************************
+ * MPS_SWIRNSET Register
+ ******************************************************************************/
+
+/* Software Interrupt Request IR5 (5) */
+#define IFX_MPS_SWIRNSET_IR5   (0x1 << 5)
+#define IFX_MPS_SWIRNSET_IR5_VAL(val)   (((val) & 0x1) << 5)
+#define IFX_MPS_SWIRNSET_IR5_SET(reg,val) (reg) = (((reg & ~IFX_MPS_SWIRNSET_IR5) | (val) & 1) << 5)
+/* Software Interrupt Request IR4 (4) */
+#define IFX_MPS_SWIRNSET_IR4   (0x1 << 4)
+#define IFX_MPS_SWIRNSET_IR4_VAL(val)   (((val) & 0x1) << 4)
+#define IFX_MPS_SWIRNSET_IR4_SET(reg,val) (reg) = (((reg & ~IFX_MPS_SWIRNSET_IR4) | (val) & 1) << 4)
+/* Software Interrupt Request IR3 (3) */
+#define IFX_MPS_SWIRNSET_IR3   (0x1 << 3)
+#define IFX_MPS_SWIRNSET_IR3_VAL(val)   (((val) & 0x1) << 3)
+#define IFX_MPS_SWIRNSET_IR3_SET(reg,val) (reg) = (((reg & ~IFX_MPS_SWIRNSET_IR3) | (val) & 1) << 3)
+/* Software Interrupt Request IR2 (2) */
+#define IFX_MPS_SWIRNSET_IR2   (0x1 << 2)
+#define IFX_MPS_SWIRNSET_IR2_VAL(val)   (((val) & 0x1) << 2)
+#define IFX_MPS_SWIRNSET_IR2_SET(reg,val) (reg) = (((reg & ~IFX_MPS_SWIRNSET_IR2) | (val) & 1) << 2)
+/* Software Interrupt Request IR1 (1) */
+#define IFX_MPS_SWIRNSET_IR1   (0x1 << 1)
+#define IFX_MPS_SWIRNSET_IR1_VAL(val)   (((val) & 0x1) << 1)
+#define IFX_MPS_SWIRNSET_IR1_SET(reg,val) (reg) = (((reg & ~IFX_MPS_SWIRNSET_IR1) | (val) & 1) << 1)
+/* Software Interrupt Request IR0 (0) */
+#define IFX_MPS_SWIRNSET_IR0   (0x1)
+#define IFX_MPS_SWIRNSET_IR0_VAL(val)   (((val) & 0x1) << 0)
+#define IFX_MPS_SWIRNSET_IR0_SET(reg,val) (reg) = (((reg & ~IFX_MPS_SWIRNSET_IR0) | (val) & 1) << 0)
+
+/*******************************************************************************
+ * MPS_SWIRNEN Register
+ ******************************************************************************/
+
+/* Software Interrupt Request IR5 (5) */
+#define IFX_MPS_SWIRNEN_IR5   (0x1 << 5)
+#define IFX_MPS_SWIRNEN_IR5_VAL(val)   (((val) & 0x1) << 5)
+#define IFX_MPS_SWIRNEN_IR5_GET(val)   ((((val) & IFX_MPS_SWIRNEN_IR5) >> 5) & 0x1)
+#define IFX_MPS_SWIRNEN_IR5_SET(reg,val) (reg) = ((reg & ~IFX_MPS_SWIRNEN_IR5) | (((val) & 0x1) << 5))
+/* Software Interrupt Request IR4 (4) */
+#define IFX_MPS_SWIRNEN_IR4   (0x1 << 4)
+#define IFX_MPS_SWIRNEN_IR4_VAL(val)   (((val) & 0x1) << 4)
+#define IFX_MPS_SWIRNEN_IR4_GET(val)   ((((val) & IFX_MPS_SWIRNEN_IR4) >> 4) & 0x1)
+#define IFX_MPS_SWIRNEN_IR4_SET(reg,val) (reg) = ((reg & ~IFX_MPS_SWIRNEN_IR4) | (((val) & 0x1) << 4))
+/* Software Interrupt Request IR3 (3) */
+#define IFX_MPS_SWIRNEN_IR3   (0x1 << 3)
+#define IFX_MPS_SWIRNEN_IR3_VAL(val)   (((val) & 0x1) << 3)
+#define IFX_MPS_SWIRNEN_IR3_GET(val)   ((((val) & IFX_MPS_SWIRNEN_IR3) >> 3) & 0x1)
+#define IFX_MPS_SWIRNEN_IR3_SET(reg,val) (reg) = ((reg & ~IFX_MPS_SWIRNEN_IR3) | (((val) & 0x1) << 3))
+/* Software Interrupt Request IR2 (2) */
+#define IFX_MPS_SWIRNEN_IR2   (0x1 << 2)
+#define IFX_MPS_SWIRNEN_IR2_VAL(val)   (((val) & 0x1) << 2)
+#define IFX_MPS_SWIRNEN_IR2_GET(val)   ((((val) & IFX_MPS_SWIRNEN_IR2) >> 2) & 0x1)
+#define IFX_MPS_SWIRNEN_IR2_SET(reg,val) (reg) = ((reg & ~IFX_MPS_SWIRNEN_IR2) | (((val) & 0x1) << 2))
+/* Software Interrupt Request IR1 (1) */
+#define IFX_MPS_SWIRNEN_IR1   (0x1 << 1)
+#define IFX_MPS_SWIRNEN_IR1_VAL(val)   (((val) & 0x1) << 1)
+#define IFX_MPS_SWIRNEN_IR1_GET(val)   ((((val) & IFX_MPS_SWIRNEN_IR1) >> 1) & 0x1)
+#define IFX_MPS_SWIRNEN_IR1_SET(reg,val) (reg) = ((reg & ~IFX_MPS_SWIRNEN_IR1) | (((val) & 0x1) << 1))
+/* Software Interrupt Request IR0 (0) */
+#define IFX_MPS_SWIRNEN_IR0   (0x1)
+#define IFX_MPS_SWIRNEN_IR0_VAL(val)   (((val) & 0x1) << 0)
+#define IFX_MPS_SWIRNEN_IR0_GET(val)   ((((val) & IFX_MPS_SWIRNEN_IR0) >> 0) & 0x1)
+#define IFX_MPS_SWIRNEN_IR0_SET(reg,val) (reg) = ((reg & ~IFX_MPS_SWIRNEN_IR0) | (((val) & 0x1) << 0))
+
+/*******************************************************************************
+ * MPS_SWIRNICR Register
+ ******************************************************************************/
+
+/* Software Interrupt Request IR5 (5) */
+#define IFX_MPS_SWIRNICR_IR5   (0x1 << 5)
+#define IFX_MPS_SWIRNICR_IR5_GET(val)   ((((val) & IFX_MPS_SWIRNICR_IR5) >> 5) & 0x1)
+/* Software Interrupt Request IR4 (4) */
+#define IFX_MPS_SWIRNICR_IR4   (0x1 << 4)
+#define IFX_MPS_SWIRNICR_IR4_GET(val)   ((((val) & IFX_MPS_SWIRNICR_IR4) >> 4) & 0x1)
+/* Software Interrupt Request IR3 (3) */
+#define IFX_MPS_SWIRNICR_IR3   (0x1 << 3)
+#define IFX_MPS_SWIRNICR_IR3_GET(val)   ((((val) & IFX_MPS_SWIRNICR_IR3) >> 3) & 0x1)
+/* Software Interrupt Request IR2 (2) */
+#define IFX_MPS_SWIRNICR_IR2   (0x1 << 2)
+#define IFX_MPS_SWIRNICR_IR2_GET(val)   ((((val) & IFX_MPS_SWIRNICR_IR2) >> 2) & 0x1)
+/* Software Interrupt Request IR1 (1) */
+#define IFX_MPS_SWIRNICR_IR1   (0x1 << 1)
+#define IFX_MPS_SWIRNICR_IR1_GET(val)   ((((val) & IFX_MPS_SWIRNICR_IR1) >> 1) & 0x1)
+/* Software Interrupt Request IR0 (0) */
+#define IFX_MPS_SWIRNICR_IR0   (0x1)
+#define IFX_MPS_SWIRNICR_IR0_GET(val)   ((((val) & IFX_MPS_SWIRNICR_IR0) >> 0) & 0x1)
+
+/*******************************************************************************
+ * MPS_SWIRNCR Register
+ ******************************************************************************/
+
+/* Software Interrupt Request IR5 (5) */
+#define IFX_MPS_SWIRNCR_IR5   (0x1 << 5)
+#define IFX_MPS_SWIRNCR_IR5_GET(val)   ((((val) & IFX_MPS_SWIRNCR_IR5) >> 5) & 0x1)
+/* Software Interrupt Request IR4 (4) */
+#define IFX_MPS_SWIRNCR_IR4   (0x1 << 4)
+#define IFX_MPS_SWIRNCR_IR4_GET(val)   ((((val) & IFX_MPS_SWIRNCR_IR4) >> 4) & 0x1)
+/* Software Interrupt Request IR3 (3) */
+#define IFX_MPS_SWIRNCR_IR3   (0x1 << 3)
+#define IFX_MPS_SWIRNCR_IR3_GET(val)   ((((val) & IFX_MPS_SWIRNCR_IR3) >> 3) & 0x1)
+/* Software Interrupt Request IR2 (2) */
+#define IFX_MPS_SWIRNCR_IR2   (0x1 << 2)
+#define IFX_MPS_SWIRNCR_IR2_GET(val)   ((((val) & IFX_MPS_SWIRNCR_IR2) >> 2) & 0x1)
+/* Software Interrupt Request IR1 (1) */
+#define IFX_MPS_SWIRNCR_IR1   (0x1 << 1)
+#define IFX_MPS_SWIRNCR_IR1_GET(val)   ((((val) & IFX_MPS_SWIRNCR_IR1) >> 1) & 0x1)
+/* Software Interrupt Request IR0 (0) */
+#define IFX_MPS_SWIRNCR_IR0   (0x1)
+#define IFX_MPS_SWIRNCR_IR0_GET(val)   ((((val) & IFX_MPS_SWIRNCR_IR0) >> 0) & 0x1)
+
+#endif
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/svip/sys0_reg.h
@@ -0,0 +1,157 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2012 Lantiq Deutschland GmbH */
+/* Copyright (C) 2018 Intel Corporation */
+
+#ifndef __SYS0_REG_H
+#define __SYS0_REG_H
+
+#define sys0_r32(reg) ltq_r32(&sys0->reg)
+#define sys0_w32(val, reg) ltq_w32(val, &sys0->reg)
+#define sys0_w32_mask(clear, set, reg) ltq_w32_mask(clear, set, &sys0->reg)
+
+/** SYS0 register structure */
+struct svip_reg_sys0 {
+	unsigned long sr; /* 0x0000 */
+	unsigned long bcr; /* 0x0004 */
+	unsigned long pll1cr; /* 0x0008 */
+	unsigned long pll2cr; /* 0x000c */
+	unsigned long tscr; /* 0x0010 */
+	unsigned long phyclkr; /* 0x0014 */
+};
+
+/*******************************************************************************
+ * SYS0 Status Register
+ ******************************************************************************/
+
+/* Endian select pin (31) */
+#define SYS0_SR_ESEL   (0x1 << 31)
+#define SYS0_SR_ESEL_GET(val)   ((((val) & SYS0_SR_ESEL) >> 31) & 0x1)
+/* Boot mode pins (27:24) */
+#define SYS0_SR_BMODE   (0xf << 24)
+#define SYS0_SR_BMODE_GET(val)   ((((val) & SYS0_SR_BMODE) >> 24) & 0xf)
+/* PLL2 Lock (18) */
+#define SYS0_SR_PLL2LOCK   (0x1 << 18)
+#define SYS0_SR_PLL2LOCK_GET(val)   ((((val) & SYS0_SR_PLL2LOCK) >> 18) & 0x1)
+/* PLL1 Lock (17) */
+#define SYS0_SR_PLL1LOCK   (0x1 << 17)
+#define SYS0_SR_PLL1LOCK_GET(val)   ((((val) & SYS0_SR_PLL1LOCK) >> 17) & 0x1)
+/* Discrete Timing Oscillator Lock (16) */
+#define SYS0_SR_DTOLOCK   (0x1 << 16)
+#define SYS0_SR_DTOLOCK_GET(val)   ((((val) & SYS0_SR_DTOLOCK) >> 16) & 0x1)
+/* Hardware Reset Indication (1) */
+#define SYS0_SR_HRSTIN   (0x1 << 1)
+#define SYS0_SR_HRSTIN_VAL(val)   (((val) & 0x1) << 1)
+#define SYS0_SR_HRSTIN_GET(val)   ((((val) & SYS0_SR_HRSTIN) >> 1) & 0x1)
+#define SYS0_SR_HRSTIN_SET(reg,val) (reg) = ((reg & ~SYS0_SR_HRSTIN) | (((val) & 0x1) << 1))
+/* Power-on Reset Indication (0) */
+#define SYS0_SR_POR   (0x1 << 0)
+#define SYS0_SR_POR_VAL(val)   (((val) & 0x1) << 0)
+#define SYS0_SR_POR_GET(val)   ((((val) & SYS0_SR_POR) >> 0) & 0x1)
+#define SYS0_SR_POR_SET(reg,val) (reg) = ((reg & ~SYS0_SR_POR) | (((val) & 0x1) << 0))
+
+/*******************************************************************************
+ * SYS0 Boot Control Register
+ ******************************************************************************/
+
+/* Configuration of Boot Source for CPU5 (25) */
+#define SYS0_BCR_BMODECPU5   (0x1 << 25)
+#define SYS0_BCR_BMODECPU5_VAL(val)   (((val) & 0x1) << 25)
+#define SYS0_BCR_BMODECPU5_GET(val)   ((((val) & SYS0_BCR_BMODECPU5) >> 25) & 0x1)
+#define SYS0_BCR_BMODECPU5_SET(reg,val) (reg) = ((reg & ~SYS0_BCR_BMODECPU5) | (((val) & 0x1) << 25))
+/* Configuration of Boot Source for CPU4 (24) */
+#define SYS0_BCR_BMODECPU4   (0x1 << 24)
+#define SYS0_BCR_BMODECPU4_VAL(val)   (((val) & 0x1) << 24)
+#define SYS0_BCR_BMODECPU4_GET(val)   ((((val) & SYS0_BCR_BMODECPU4) >> 24) & 0x1)
+#define SYS0_BCR_BMODECPU4_SET(reg,val) (reg) = ((reg & ~SYS0_BCR_BMODECPU4) | (((val) & 0x1) << 24))
+/* Configuration of Boot Source for CPU3 (23) */
+#define SYS0_BCR_BMODECPU3   (0x1 << 23)
+#define SYS0_BCR_BMODECPU3_VAL(val)   (((val) & 0x1) << 23)
+#define SYS0_BCR_BMODECPU3_GET(val)   ((((val) & SYS0_BCR_BMODECPU3) >> 23) & 0x1)
+#define SYS0_BCR_BMODECPU3_SET(reg,val) (reg) = ((reg & ~SYS0_BCR_BMODECPU3) | (((val) & 0x1) << 23))
+/* Configuration of Boot Source for CPU2 (22) */
+#define SYS0_BCR_BMODECPU2   (0x1 << 22)
+#define SYS0_BCR_BMODECPU2_VAL(val)   (((val) & 0x1) << 22)
+#define SYS0_BCR_BMODECPU2_GET(val)   ((((val) & SYS0_BCR_BMODECPU2) >> 22) & 0x1)
+#define SYS0_BCR_BMODECPU2_SET(reg,val) (reg) = ((reg & ~SYS0_BCR_BMODECPU2) | (((val) & 0x1) << 22))
+/* Configuration of Boot Source for CPU1 (21) */
+#define SYS0_BCR_BMODECPU1   (0x1 << 21)
+#define SYS0_BCR_BMODECPU1_VAL(val)   (((val) & 0x1) << 21)
+#define SYS0_BCR_BMODECPU1_GET(val)   ((((val) & SYS0_BCR_BMODECPU1) >> 21) & 0x1)
+#define SYS0_BCR_BMODECPU1_SET(reg,val) (reg) = ((reg & ~SYS0_BCR_BMODECPU1) | (((val) & 0x1) << 21))
+/* Configuration of Boot Source for CPU0 (20:16) */
+#define SYS0_BCR_BMODECPU0   (0x1f << 16)
+#define SYS0_BCR_BMODECPU0_VAL(val)   (((val) & 0x1f) << 16)
+#define SYS0_BCR_BMODECPU0_GET(val)   ((((val) & SYS0_BCR_BMODECPU0) >> 16) & 0x1f)
+#define SYS0_BCR_BMODECPU0_SET(reg,val) (reg) = ((reg & ~SYS0_BCR_BMODECPU0) | (((val) & 0x1f) << 16))
+/* Configuration of Endianess for CPU5 (5) */
+#define SYS0_BCR_ESELCPU5   (0x1 << 5)
+#define SYS0_BCR_ESELCPU5_VAL(val)   (((val) & 0x1) << 5)
+#define SYS0_BCR_ESELCPU5_GET(val)   ((((val) & SYS0_BCR_ESELCPU5) >> 5) & 0x1)
+#define SYS0_BCR_ESELCPU5_SET(reg,val) (reg) = ((reg & ~SYS0_BCR_ESELCPU5) | (((val) & 0x1) << 5))
+/* Configuration of Endianess for CPU4 (4) */
+#define SYS0_BCR_ESELCPU4   (0x1 << 4)
+#define SYS0_BCR_ESELCPU4_VAL(val)   (((val) & 0x1) << 4)
+#define SYS0_BCR_ESELCPU4_GET(val)   ((((val) & SYS0_BCR_ESELCPU4) >> 4) & 0x1)
+#define SYS0_BCR_ESELCPU4_SET(reg,val) (reg) = ((reg & ~SYS0_BCR_ESELCPU4) | (((val) & 0x1) << 4))
+/* Configuration of Endianess for CPU3 (3) */
+#define SYS0_BCR_ESELCPU3   (0x1 << 3)
+#define SYS0_BCR_ESELCPU3_VAL(val)   (((val) & 0x1) << 3)
+#define SYS0_BCR_ESELCPU3_GET(val)   ((((val) & SYS0_BCR_ESELCPU3) >> 3) & 0x1)
+#define SYS0_BCR_ESELCPU3_SET(reg,val) (reg) = ((reg & ~SYS0_BCR_ESELCPU3) | (((val) & 0x1) << 3))
+/* Configuration of Endianess for CPU2 (2) */
+#define SYS0_BCR_ESELCPU2   (0x1 << 2)
+#define SYS0_BCR_ESELCPU2_VAL(val)   (((val) & 0x1) << 2)
+#define SYS0_BCR_ESELCPU2_GET(val)   ((((val) & SYS0_BCR_ESELCPU2) >> 2) & 0x1)
+#define SYS0_BCR_ESELCPU2_SET(reg,val) (reg) = ((reg & ~SYS0_BCR_ESELCPU2) | (((val) & 0x1) << 2))
+/* Configuration of Endianess for CPU1 (1) */
+#define SYS0_BCR_ESELCPU1   (0x1 << 1)
+#define SYS0_BCR_ESELCPU1_VAL(val)   (((val) & 0x1) << 1)
+#define SYS0_BCR_ESELCPU1_GET(val)   ((((val) & SYS0_BCR_ESELCPU1) >> 1) & 0x1)
+#define SYS0_BCR_ESELCPU1_SET(reg,val) (reg) = ((reg & ~SYS0_BCR_ESELCPU1) | (((val) & 0x1) << 1))
+/* Configuration of Endianess for CPU0  (0) */
+#define SYS0_BCR_ESELCPU0   (0x1)
+#define SYS0_BCR_ESELCPU0_VAL(val)   (((val) & 0x1) << 0)
+#define SYS0_BCR_ESELCPU0_GET(val)   ((((val) & SYS0_BCR_ESELCPU0) >> 0) & 0x1)
+#define SYS0_BCR_ESELCPU0_SET(reg,val) (reg) = ((reg & ~SYS0_BCR_ESELCPU0) | (((val) & 0x1) << 0))
+
+/*******************************************************************************
+ * PLL1 Control Register
+ ******************************************************************************/
+
+/* PLL1 Bypass Enable (31) */
+#define SYS0_PLL1CR_OSCBYP   (0x1 << 31)
+#define SYS0_PLL1CR_OSCBYP_VAL(val)   (((val) & 0x1) << 31)
+#define SYS0_PLL1CR_OSCBYP_GET(val)   ((((val) & SYS0_PLL1CR_OSCBYP) >> 31) & 0x1)
+#define SYS0_PLL1CR_OSCBYP_SET(reg,val) (reg) = ((reg & ~SYS0_PLL1CR_OSCBYP) | (((val) & 0x1) << 31))
+/* PLL1 Divider Value (1:0) */
+#define SYS0_PLL1CR_PLLDIV   (0x3)
+#define SYS0_PLL1CR_PLLDIV_VAL(val)   (((val) & 0x3) << 0)
+#define SYS0_PLL1CR_PLLDIV_GET(val)   ((((val) & SYS0_PLL1CR_PLLDIV) >> 0) & 0x3)
+#define SYS0_PLL1CR_PLLDIV_SET(reg,val) (reg) = ((reg & ~SYS0_PLL1CR_PLLDIV) | (((val) & 0x3) << 0))
+
+/*******************************************************************************
+ * PLL2 Control Register
+ ******************************************************************************/
+
+/* PLL2 clear deepsleep (31) */
+#define SYS0_PLL2CR_CLRDS   (0x1 << 31)
+#define SYS0_PLL2CR_CLRDS_VAL(val)   (((val) & 0x1) << 31)
+#define SYS0_PLL2CR_CLRDS_GET(val)   ((((val) & SYS0_PLL2CR_CLRDS) >> 31) & 0x1)
+#define SYS0_PLL2CR_CLRDS_SET(reg,val) (reg) = ((reg & ~SYS0_PLL2CR_CLRDS) | (((val) & 0x1) << 31))
+/* PLL2 set deepsleep (30) */
+#define SYS0_PLL2CR_SETDS   (0x1 << 30)
+#define SYS0_PLL2CR_SETDS_VAL(val)   (((val) & 0x1) << 30)
+#define SYS0_PLL2CR_SETDS_GET(val)   ((((val) & SYS0_PLL2CR_SETDS) >> 30) & 0x1)
+#define SYS0_PLL2CR_SETDS_SET(reg,val) (reg) = ((reg & ~SYS0_PLL2CR_SETDS) | (((val) & 0x1) << 30))
+/* PLL2 Fractional division enable (16) */
+#define SYS0_PLL2CR_FRACTEN   (0x1 << 16)
+#define SYS0_PLL2CR_FRACTEN_VAL(val)   (((val) & 0x1) << 16)
+#define SYS0_PLL2CR_FRACTEN_GET(val)   ((((val) & SYS0_PLL2CR_FRACTEN) >> 16) & 0x1)
+#define SYS0_PLL2CR_FRACTEN_SET(reg,val) (reg) = ((reg & ~SYS0_PLL2CR_FRACTEN) | (((val) & 0x1) << 16))
+/* PLL2 Fractional division value (9:0) */
+#define SYS0_FRACTVAL   (0x3f)
+#define SYS0_FRACTVAL_VAL(val)   (((val) & 0x3f) << 0)
+#define SYS0_FRACTVAL_GET(val)   ((((val) & SYS0_FRACTVAL) >> 0) & 0x3f)
+#define SYS0_FRACTVAL_SET(reg,val) (reg) = ((reg & ~SYS0_FRACTVAL) | (((val) & 0x3f) << 0))
+
+#endif
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/svip/sys1_reg.h
@@ -0,0 +1,362 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2012 Lantiq Deutschland GmbH */
+/* Copyright (C) 2018 Intel Corporation */
+
+#ifndef __SYS1_REG_H
+#define __SYS1_REG_H
+
+#define sys1_r32(reg) ltq_r32(&sys1->reg)
+#define sys1_w32(val, reg) ltq_w32(val, &sys1->reg)
+#define sys1_w32_mask(clear, set, reg) ltq_w32_mask(clear, set, &sys1->reg)
+
+/** SYS1 register structure */
+struct svip_reg_sys1 {
+	unsigned long clksr; /* 0x0000 */
+	unsigned long clkenr; /* 0x0004 */
+	unsigned long clkclr; /* 0x0008 */
+	unsigned long reserved0[1];
+	unsigned long l2ccr; /* 0x0010 */
+	unsigned long fpicr; /* 0x0014 */
+	unsigned long wdtcr; /* 0x0018 */
+	unsigned long reserved1[1];
+	unsigned long cpucr[6]; /* 0x0020 */
+	unsigned long reserved2[2];
+	unsigned long rsr; /* 0x0040 */
+	unsigned long rreqr; /* 0x0044 */
+	unsigned long rrlsr; /* 0x0048 */
+	unsigned long rbtr; /* 0x004c */
+	unsigned long irncr; /* 0x0050 */
+	unsigned long irnicr; /* 0x0054 */
+	unsigned long irnen; /* 0x0058 */
+	unsigned long reserved3[1];
+	unsigned long cpursr[6]; /* 0x0060 */
+	unsigned long reserved4[2];
+	unsigned long cpusrssr[6]; /* 0x0080 */
+	unsigned long reserved5[2];
+	unsigned long cpuwrssr[6]; /* 0x00a0 */
+};
+
+/*******************************************************************************
+ * SYS1 Clock Status Register
+ ******************************************************************************/
+/* (r) Clock Enable for L2C */
+#define SYS1_CLKSR_L2C (0x1 << 31)
+/* (r) Clock Enable for DDR2 */
+#define SYS1_CLKSR_DDR2 (0x1 << 30)
+/* (r) Clock Enable for SMI2 */
+#define SYS1_CLKSR_SMI2 (0x1 << 29)
+/* (r) Clock Enable for SMI1 */
+#define SYS1_CLKSR_SMI1 (0x1 << 28)
+/* (r) Clock Enable for SMI0 */
+#define SYS1_CLKSR_SMI0 (0x1 << 27)
+/* (r) Clock Enable for FMI0 */
+#define SYS1_CLKSR_FMI0 (0x1 << 26)
+/* (r) Clock Enable for PORT0 */
+#define SYS1_CLKSR_PORT0 (0x1 << 0)
+/* (r) Clock Enable for PCM3 */
+#define SYS1_CLKSR_PCM3 (0x1 << 19)
+/* (r) Clock Enable for PCM2 */
+#define SYS1_CLKSR_PCM2 (0x1 << 18)
+/* (r) Clock Enable for PCM1 */
+#define SYS1_CLKSR_PCM1 (0x1 << 17)
+/* (r) Clock Enable for PCM0 */
+#define SYS1_CLKSR_PCM0 (0x1 << 16)
+/* (r) Clock Enable for ASC1 */
+#define SYS1_CLKSR_ASC1 (0x1 << 15)
+/* (r) Clock Enable for ASC0 */
+#define SYS1_CLKSR_ASC0 (0x1 << 14)
+/* (r) Clock Enable for SSC2 */
+#define SYS1_CLKSR_SSC2 (0x1 << 13)
+/* (r) Clock Enable for SSC1 */
+#define SYS1_CLKSR_SSC1 (0x1 << 12)
+/* (r) Clock Enable for SSC0 */
+#define SYS1_CLKSR_SSC0 (0x1 << 11)
+/* (r) Clock Enable for GPTC */
+#define SYS1_CLKSR_GPTC (0x1 << 10)
+/* (r) Clock Enable for DMA */
+#define SYS1_CLKSR_DMA (0x1 << 9)
+/* (r) Clock Enable for FSCT */
+#define SYS1_CLKSR_FSCT (0x1 << 8)
+/* (r) Clock Enable for ETHSW */
+#define SYS1_CLKSR_ETHSW (0x1 << 7)
+/* (r) Clock Enable for EBU */
+#define SYS1_CLKSR_EBU (0x1 << 6)
+/* (r) Clock Enable for TRNG */
+#define SYS1_CLKSR_TRNG (0x1 << 5)
+/* (r) Clock Enable for DEU */
+#define SYS1_CLKSR_DEU (0x1 << 4)
+/* (r) Clock Enable for PORT3 */
+#define SYS1_CLKSR_PORT3 (0x1 << 3)
+/* (r) Clock Enable for PORT2 */
+#define SYS1_CLKSR_PORT2 (0x1 << 2)
+/* (r) Clock Enable for PORT1 */
+#define SYS1_CLKSR_PORT1 (0x1 << 1)
+
+/*******************************************************************************
+ * SYS1 Clock Enable Register
+ ******************************************************************************/
+/* (w) Clock Enable Request for L2C */
+#define SYS1_CLKENR_L2C (0x1 << 31)
+/* (w) Clock Enable Request for DDR2 */
+#define SYS1_CLKENR_DDR2 (0x1 << 30)
+/* (w) Clock Enable Request for SMI2 */
+#define SYS1_CLKENR_SMI2 (0x1 << 29)
+/* (w) Clock Enable Request for SMI1 */
+#define SYS1_CLKENR_SMI1 (0x1 << 28)
+/* (w) Clock Enable Request for SMI0 */
+#define SYS1_CLKENR_SMI0 (0x1 << 27)
+/* (w) Clock Enable Request for FMI0 */
+#define SYS1_CLKENR_FMI0 (0x1 << 26)
+/* (w) Clock Enable Request for PORT0 */
+#define SYS1_CLKENR_PORT0 (0x1 << 0)
+/* (w) Clock Enable Request for PCM3 */
+#define SYS1_CLKENR_PCM3 (0x1 << 19)
+/* (w) Clock Enable Request for PCM2 */
+#define SYS1_CLKENR_PCM2 (0x1 << 18)
+/* (w) Clock Enable Request for PCM1 */
+#define SYS1_CLKENR_PCM1 (0x1 << 17)
+/* (w) Clock Enable Request for PCM0 */
+#define SYS1_CLKENR_PCM0 (0x1 << 16)
+/* (w) Clock Enable Request for ASC1 */
+#define SYS1_CLKENR_ASC1 (0x1 << 15)
+/* (w) Clock Enable Request for ASC0 */
+#define SYS1_CLKENR_ASC0 (0x1 << 14)
+/* (w) Clock Enable Request for SSC2 */
+#define SYS1_CLKENR_SSC2 (0x1 << 13)
+/* (w) Clock Enable Request for SSC1 */
+#define SYS1_CLKENR_SSC1 (0x1 << 12)
+/* (w) Clock Enable Request for SSC0 */
+#define SYS1_CLKENR_SSC0 (0x1 << 11)
+/* (w) Clock Enable Request for GPTC */
+#define SYS1_CLKENR_GPTC (0x1 << 10)
+/* (w) Clock Enable Request for DMA */
+#define SYS1_CLKENR_DMA (0x1 << 9)
+/* (w) Clock Enable Request for FSCT */
+#define SYS1_CLKENR_FSCT (0x1 << 8)
+/* (w) Clock Enable Request for ETHSW */
+#define SYS1_CLKENR_ETHSW (0x1 << 7)
+/* (w) Clock Enable Request for EBU */
+#define SYS1_CLKENR_EBU (0x1 << 6)
+/* (w) Clock Enable Request for TRNG */
+#define SYS1_CLKENR_TRNG (0x1 << 5)
+/* (w) Clock Enable Request for DEU */
+#define SYS1_CLKENR_DEU (0x1 << 4)
+/* (w) Clock Enable Request for PORT3 */
+#define SYS1_CLKENR_PORT3 (0x1 << 3)
+/* (w) Clock Enable Request for PORT2 */
+#define SYS1_CLKENR_PORT2 (0x1 << 2)
+/* (w) Clock Enable Request for PORT1 */
+#define SYS1_CLKENR_PORT1 (0x1 << 1)
+
+/*******************************************************************************
+ * SYS1 Clock Clear Register
+ ******************************************************************************/
+/* (w) Clock Disable Request for L2C */
+#define SYS1_CLKCLR_L2C (0x1 << 31)
+/* (w) Clock Disable Request for DDR2 */
+#define SYS1_CLKCLR_DDR2 (0x1 << 30)
+/* (w) Clock Disable Request for SMI2 */
+#define SYS1_CLKCLR_SMI2 (0x1 << 29)
+/* (w) Clock Disable Request for SMI1 */
+#define SYS1_CLKCLR_SMI1 (0x1 << 28)
+/* (w) Clock Disable Request for SMI0 */
+#define SYS1_CLKCLR_SMI0 (0x1 << 27)
+/* (w) Clock Disable Request for FMI0 */
+#define SYS1_CLKCLR_FMI0 (0x1 << 26)
+/* (w) Clock Disable Request for PORT0 */
+#define SYS1_CLKCLR_PORT0 (0x1 << 0)
+/* (w) Clock Disable Request for PCM3 */
+#define SYS1_CLKCLR_PCM3 (0x1 << 19)
+/* (w) Clock Disable Request for PCM2 */
+#define SYS1_CLKCLR_PCM2 (0x1 << 18)
+/* (w) Clock Disable Request for PCM1 */
+#define SYS1_CLKCLR_PCM1 (0x1 << 17)
+/* (w) Clock Disable Request for PCM0 */
+#define SYS1_CLKCLR_PCM0 (0x1 << 16)
+/* (w) Clock Disable Request for ASC1 */
+#define SYS1_CLKCLR_ASC1 (0x1 << 15)
+/* (w) Clock Disable Request for ASC0 */
+#define SYS1_CLKCLR_ASC0 (0x1 << 14)
+/* (w) Clock Disable Request for SSC2 */
+#define SYS1_CLKCLR_SSC2 (0x1 << 13)
+/* (w) Clock Disable Request for SSC1 */
+#define SYS1_CLKCLR_SSC1 (0x1 << 12)
+/* (w) Clock Disable Request for SSC0 */
+#define SYS1_CLKCLR_SSC0 (0x1 << 11)
+/* (w) Clock Disable Request for GPTC */
+#define SYS1_CLKCLR_GPTC (0x1 << 10)
+/* (w) Clock Disable Request for DMA */
+#define SYS1_CLKCLR_DMA (0x1 << 9)
+/* (w) Clock Disable Request for FSCT */
+#define SYS1_CLKCLR_FSCT (0x1 << 8)
+/* (w) Clock Disable Request for ETHSW */
+#define SYS1_CLKCLR_ETHSW (0x1 << 7)
+/* (w) Clock Disable Request for EBU */
+#define SYS1_CLKCLR_EBU (0x1 << 6)
+/* (w) Clock Disable Request for TRNG */
+#define SYS1_CLKCLR_TRNG (0x1 << 5)
+/* (w) Clock Disable Request for DEU */
+#define SYS1_CLKCLR_DEU (0x1 << 4)
+/* (w) Clock Disable Request for PORT3 */
+#define SYS1_CLKCLR_PORT3 (0x1 << 3)
+/* (w) Clock Disable Request for PORT2 */
+#define SYS1_CLKCLR_PORT2 (0x1 << 2)
+/* (w) Clock Disable Request for PORT1 */
+#define SYS1_CLKCLR_PORT1 (0x1 << 1)
+
+/*******************************************************************************
+ * SYS1 FPI Control Register
+ ******************************************************************************/
+
+/* FPI Bus Clock divider (0) */
+#define SYS1_FPICR_FPIDIV   (0x1)
+#define SYS1_FPICR_FPIDIV_VAL(val)   (((val) & 0x1) << 0)
+#define SYS1_FPICR_FPIDIV_GET(val)   ((((val) & SYS1_FPICR_FPIDIV) >> 0) & 0x1)
+#define SYS1_FPICR_FPIDIV_SET(reg,val) (reg) = ((reg & ~SYS1_FPICR_FPIDIV) | (((val) & 0x1) << 0))
+
+/*******************************************************************************
+ * SYS1 Clock Control Register for CPUn
+ ******************************************************************************/
+
+/* Enable bit for clock of CPUn (1) */
+#define SYS1_CPUCR_CPUCLKEN    (0x1 << 1)
+#define SYS1_CPUCR_CPUCLKEN_VAL(val)   (((val) & 0x1) << 1)
+#define SYS1_CPUCR_CPUCLKEN_GET(val)   ((((val) & SYS1_CPUCR_CPUCLKEN) >> 1) & 0x1)
+#define SYS1_CPUCR_CPUCLKEN_SET(reg,val) (reg) = ((reg & ~SYS1_CPUCR_CPUCLKEN) | (((val) & 0x1) << 1))
+/* Divider factor for clock of CPUn (0) */
+#define SYS1_CPUCR_CPUDIV    (0x1)
+#define SYS1_CPUCR_CPUDIV_VAL(val)   (((val) & 0x1) << 0)
+#define SYS1_CPUCR_CPUDIV_GET(val)   ((((val) & SYS1_CPUCR_CPUDIV) >> 0) & 0x1)
+#define SYS1_CPUCR_CPUDIV_SET(reg,val) (reg) = ((reg & ~SYS1_CPUCR_CPUDIV) | (((val) & 0x1) << 0))
+
+/*******************************************************************************
+ * SYS1 Reset Request Register
+ ******************************************************************************/
+
+/* HRSTOUT Reset Request (18) */
+#define SYS1_RREQ_HRSTOUT   (0x1 << 18)
+#define SYS1_RREQ_HRSTOUT_VAL(val)   (((val) & 0x1) << 18)
+#define SYS1_RREQ_HRSTOUT_SET(reg,val) (reg) = (((reg & ~SYS1_RREQ_HRSTOUT) | (((val) & 1) << 18))
+						    /* FBS0 Reset Request (17) */
+#define SYS1_RREQ_FBS0   (0x1 << 17)
+#define SYS1_RREQ_FBS0_VAL(val)   (((val) & 0x1) << 17)
+#define SYS1_RREQ_FBS0_SET(reg,val) (reg) = (((reg & ~SYS1_RREQ_FBS0) | (((val) & 1) << 17))
+						 /* SUBSYS Reset Request (16) */
+#define SYS1_RREQ_SUBSYS   (0x1 << 16)
+#define SYS1_RREQ_SUBSYS_VAL(val)   (((val) & 0x1) << 16)
+#define SYS1_RREQ_SUBSYS_SET(reg,val) (reg) = (((reg & ~SYS1_RREQ_SUBSYS) | (((val) & 1) << 16))
+						   /* Watchdog5 Reset Request (13) */
+#define SYS1_RREQ_WDT5   (0x1 << 13)
+#define SYS1_RREQ_WDT5_VAL(val)   (((val) & 0x1) << 13)
+#define SYS1_RREQ_WDT5_SET(reg,val) (reg) = (((reg & ~SYS1_RREQ_WDT5) | (((val) & 1) << 13))
+						 /* Watchdog4 Reset Request (12) */
+#define SYS1_RREQ_WDT4   (0x1 << 12)
+#define SYS1_RREQ_WDT4_VAL(val)   (((val) & 0x1) << 12)
+#define SYS1_RREQ_WDT4_SET(reg,val) (reg) = (((reg & ~SYS1_RREQ_WDT4) | (((val) & 1) << 12))
+						 /* Watchdog3 Reset Request (11) */
+#define SYS1_RREQ_WDT3   (0x1 << 11)
+#define SYS1_RREQ_WDT3_VAL(val)   (((val) & 0x1) << 11)
+#define SYS1_RREQ_WDT3_SET(reg,val) (reg) = (((reg & ~SYS1_RREQ_WDT3) | (((val) & 1) << 11))
+						 /* Watchdog2 Reset Request (10) */
+#define SYS1_RREQ_WDT2   (0x1 << 10)
+#define SYS1_RREQ_WDT2_VAL(val)   (((val) & 0x1) << 10)
+#define SYS1_RREQ_WDT2_SET(reg,val) (reg) = (((reg & ~SYS1_RREQ_WDT2) | (((val) & 1) << 10))
+						 /* Watchdog1 Reset Request (9) */
+#define SYS1_RREQ_WDT1   (0x1 << 9)
+#define SYS1_RREQ_WDT1_VAL(val)   (((val) & 0x1) << 9)
+#define SYS1_RREQ_WDT1_SET(reg,val) (reg) = (((reg & ~SYS1_RREQ_WDT1) | (((val) & 1) << 9))
+						 /* Watchdog0 Reset Request (8) */
+#define SYS1_RREQ_WDT0   (0x1 << 8)
+#define SYS1_RREQ_WDT0_VAL(val)   (((val) & 0x1) << 8)
+#define SYS1_RREQ_WDT0_SET(reg,val) (reg) = (((reg & ~SYS1_RREQ_WDT0) | (((val) & 1) << 8))
+						 /* CPU5 Reset Request (5) */
+#define SYS1_RREQ_CPU5   (0x1 << 5)
+#define SYS1_RREQ_CPU5_VAL(val)   (((val) & 0x1) << 5)
+#define SYS1_RREQ_CPU5_SET(reg,val) (reg) = ((reg & ~SYS1_RREQ_CPU5) | (((val) & 1) << 5))
+						 /* CPU4 Reset Request (4) */
+#define SYS1_RREQ_CPU4   (0x1 << 4)
+#define SYS1_RREQ_CPU4_VAL(val)   (((val) & 0x1) << 4)
+#define SYS1_RREQ_CPU4_SET(reg,val) (reg) = ((reg & ~SYS1_RREQ_CPU4) | (((val) & 1) << 4))
+						 /* CPU3 Reset Request (3) */
+#define SYS1_RREQ_CPU3   (0x1 << 3)
+#define SYS1_RREQ_CPU3_VAL(val)   (((val) & 0x1) << 3)
+#define SYS1_RREQ_CPU3_SET(reg,val) (reg) = ((reg & ~SYS1_RREQ_CPU3) | (((val) & 1) << 3))
+						 /* CPU2 Reset Request (2) */
+#define SYS1_RREQ_CPU2   (0x1 << 2)
+#define SYS1_RREQ_CPU2_VAL(val)   (((val) & 0x1) << 2)
+#define SYS1_RREQ_CPU2_SET(reg,val) (reg) = ((reg & ~SYS1_RREQ_CPU2) | (((val) & 1) << 2))
+						 /* CPU1 Reset Request (1) */
+#define SYS1_RREQ_CPU1   (0x1 << 1)
+#define SYS1_RREQ_CPU1_VAL(val)   (((val) & 0x1) << 1)
+#define SYS1_RREQ_CPU1_SET(reg,val) (reg) = ((reg & ~SYS1_RREQ_CPU1) | (((val) & 1) << 1))
+/* CPU0 Reset Request (0) */
+#define SYS1_RREQ_CPU0   (0x1)
+#define SYS1_RREQ_CPU0_VAL(val)   (((val) & 0x1) << 0)
+#define SYS1_RREQ_CPU0_SET(reg,val) (reg) = ((reg & ~SYS1_RREQ_CPU0) | (((val) & 1) << 0))
+
+/*******************************************************************************
+ * SYS1 Reset Release Register
+ ******************************************************************************/
+
+/* HRSTOUT Reset Release (18) */
+#define SYS1_RRLSR_HRSTOUT   (0x1 << 18)
+#define SYS1_RRLSR_HRSTOUT_VAL(val)   (((val) & 0x1) << 18)
+#define SYS1_RRLSR_HRSTOUT_SET(reg,val) (reg) = ((reg & ~SYS1_RRLSR_HRSTOUT) | (((val) & 1) << 18))
+/* FBS0 Reset Release (17) */
+#define SYS1_RRLSR_FBS0   (0x1 << 17)
+#define SYS1_RRLSR_FBS0_VAL(val)   (((val) & 0x1) << 17)
+#define SYS1_RRLSR_FBS0_SET(reg,val) (reg) = ((reg & ~SYS1_RRLSR_FBS0) | (((val) & 1) << 17))
+/* SUBSYS Reset Release (16) */
+#define SYS1_RRLSR_SUBSYS   (0x1 << 16)
+#define SYS1_RRLSR_SUBSYS_VAL(val)   (((val) & 0x1) << 16)
+#define SYS1_RRLSR_SUBSYS_SET(reg,val) (reg) = ((reg & ~SYS1_RRLSR_SUBSYS) | (((val) & 1) << 16))
+/* Watchdog5 Reset Release (13) */
+#define SYS1_RRLSR_WDT5   (0x1 << 13)
+#define SYS1_RRLSR_WDT5_VAL(val)   (((val) & 0x1) << 13)
+#define SYS1_RRLSR_WDT5_SET(reg,val) (reg) = ((reg & ~SYS1_RRLSR_WDT5) | (((val) & 1) << 13))
+/* Watchdog4 Reset Release (12) */
+#define SYS1_RRLSR_WDT4   (0x1 << 12)
+#define SYS1_RRLSR_WDT4_VAL(val)   (((val) & 0x1) << 12)
+#define SYS1_RRLSR_WDT4_SET(reg,val) (reg) = ((reg & ~SYS1_RRLSR_WDT4) | (((val) & 1) << 12))
+/* Watchdog3 Reset Release (11) */
+#define SYS1_RRLSR_WDT3   (0x1 << 11)
+#define SYS1_RRLSR_WDT3_VAL(val)   (((val) & 0x1) << 11)
+#define SYS1_RRLSR_WDT3_SET(reg,val) (reg) = ((reg & ~SYS1_RRLSR_WDT3) | (((val) & 1) << 11))
+/* Watchdog2 Reset Release (10) */
+#define SYS1_RRLSR_WDT2   (0x1 << 10)
+#define SYS1_RRLSR_WDT2_VAL(val)   (((val) & 0x1) << 10)
+#define SYS1_RRLSR_WDT2_SET(reg,val) (reg) = ((reg & ~SYS1_RRLSR_WDT2) | (((val) & 1) << 10))
+/* Watchdog1 Reset Release (9) */
+#define SYS1_RRLSR_WDT1   (0x1 << 9)
+#define SYS1_RRLSR_WDT1_VAL(val)   (((val) & 0x1) << 9)
+#define SYS1_RRLSR_WDT1_SET(reg,val) (reg) = ((reg & ~SYS1_RRLSR_WDT1) | (((val) & 1) << 9))
+/* Watchdog0 Reset Release (8) */
+#define SYS1_RRLSR_WDT0   (0x1 << 8)
+#define SYS1_RRLSR_WDT0_VAL(val)   (((val) & 0x1) << 8)
+#define SYS1_RRLSR_WDT0_SET(reg,val) (reg) = ((reg & ~SYS1_RRLSR_WDT0) | (((val) & 1) << 8))
+/* CPU5 Reset Release (5) */
+#define SYS1_RRLSR_CPU5   (0x1 << 5)
+#define SYS1_RRLSR_CPU5_VAL(val)   (((val) & 0x1) << 5)
+#define SYS1_RRLSR_CPU5_SET(reg,val) (reg) = ((reg & ~SYS1_RRLSR_CPU5) | (((val) & 1) << 5))
+/* CPU4 Reset Release (4) */
+#define SYS1_RRLSR_CPU4   (0x1 << 4)
+#define SYS1_RRLSR_CPU4_VAL(val)   (((val) & 0x1) << 4)
+#define SYS1_RRLSR_CPU4_SET(reg,val) (reg) = ((reg & ~SYS1_RRLSR_CPU4) | (((val) & 1) << 4))
+/* CPU3 Reset Release (3) */
+#define SYS1_RRLSR_CPU3   (0x1 << 3)
+#define SYS1_RRLSR_CPU3_VAL(val)   (((val) & 0x1) << 3)
+#define SYS1_RRLSR_CPU3_SET(reg,val) (reg) = ((reg & ~SYS1_RRLSR_CPU3) | (((val) & 1) << 3))
+/* CPU2 Reset Release (2) */
+#define SYS1_RRLSR_CPU2   (0x1 << 2)
+#define SYS1_RRLSR_CPU2_VAL(val)   (((val) & 0x1) << 2)
+#define SYS1_RRLSR_CPU2_SET(reg,val) (reg) = ((reg & ~SYS1_RRLSR_CPU2) | (((val) & 1) << 2))
+/* CPU1 Reset Release (1) */
+#define SYS1_RRLSR_CPU1   (0x1 << 1)
+#define SYS1_RRLSR_CPU1_VAL(val)   (((val) & 0x1) << 1)
+#define SYS1_RRLSR_CPU1_SET(reg,val) (reg) = ((reg & ~SYS1_RRLSR_CPU1) | (((val) & 1) << 1))
+/* CPU0 Reset Release (0) */
+#define SYS1_RRLSR_CPU0   (0x1)
+#define SYS1_RRLSR_CPU0_VAL(val)   (((val) & 0x1) << 0)
+#define SYS1_RRLSR_CPU0_SET(reg,val) (reg) = ((reg & ~SYS1_RRLSR_CPU0) | (((val) & 1) << 0))
+
+#endif
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/svip/sys2_reg.h
@@ -0,0 +1,486 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2012 Lantiq Deutschland GmbH */
+/* Copyright (C) 2018 Intel Corporation */
+
+#ifndef __SYS2_REG_H
+#define __SYS2_REG_H
+
+#define sys2_r32(reg) ltq_r32(&sys2->reg)
+#define sys2_w32(val, reg) ltq_w32(val, &sys2->reg)
+#define sys2_w32_mask(clear, set, reg) ltq_w32_mask(clear, set, &sys2->reg)
+
+/** SYS2 register structure */
+struct svip_reg_sys2 {
+	volatile unsigned long  clksr;  /*  0x0000 */
+	volatile unsigned long  clkenr;  /*  0x0004 */
+	volatile unsigned long  clkclr;  /*  0x0008 */
+	volatile unsigned long  reserved0[1];
+	volatile unsigned long  rsr;  /*  0x0010 */
+	volatile unsigned long  rreqr;  /*  0x0014 */
+	volatile unsigned long  rrlsr;  /*  0x0018 */
+};
+
+/*******************************************************************************
+ * SYS2 Clock Status Register
+ ******************************************************************************/
+
+/* Clock Enable for PORT4 */
+#define SYS2_CLKSR_PORT4 (0x1 << 27)
+#define SYS2_CLKSR_PORT4_VAL(val) (((val) & 0x1) << 27)
+#define SYS2_CLKSR_PORT4_GET(val) (((val) & SYS2_CLKSR_PORT4) >> 27)
+/* Clock Enable for HWSYNC */
+#define SYS2_CLKSR_HWSYNC (0x1 << 26)
+#define SYS2_CLKSR_HWSYNC_VAL(val) (((val) &
+#define SYS2_CLKSR_HWSYNC_GET(val) (((val) & SYS2_CLKSR_HWSYNC) >> 26)
+					 /* Clock Enable for MBS */
+#define SYS2_CLKSR_MBS (0x1 << 25)
+#define SYS2_CLKSR_MBS_VAL(val) (((val) & 0x1) << 25)
+#define SYS2_CLKSR_MBS_GET(val) (((val) & SYS2_CLKSR_MBS) >> 25)
+					 /* Clock Enable for SWINT */
+#define SYS2_CLKSR_SWINT (0x1 << 24)
+#define SYS2_CLKSR_SWINT_VAL(val) (((val) & 0x1) << 24)
+#define SYS2_CLKSR_SWINT_GET(val) (((val) & SYS2_CLKSR_SWINT) >> 24)
+					 /* Clock Enable for HWACC3 */
+#define SYS2_CLKSR_HWACC3 (0x1 << 19)
+#define SYS2_CLKSR_HWACC3_VAL(val) (((val) &
+#define SYS2_CLKSR_HWACC3_GET(val) (((val) & SYS2_CLKSR_HWACC3) >> 19)
+					 /* Clock Enable for HWACC2 */
+#define SYS2_CLKSR_HWACC2 (0x1 << 18)
+#define SYS2_CLKSR_HWACC2_VAL(val) (((val) &
+#define SYS2_CLKSR_HWACC2_GET(val) (((val) & SYS2_CLKSR_HWACC2) >> 18)
+					 /* Clock Enable for HWACC1 */
+#define SYS2_CLKSR_HWACC1 (0x1 << 17)
+#define SYS2_CLKSR_HWACC1_VAL(val) (((val) &
+#define SYS2_CLKSR_HWACC1_GET(val) (((val) & SYS2_CLKSR_HWACC1) >> 17)
+					 /* Clock Enable for HWACC0 */
+#define SYS2_CLKSR_HWACC0 (0x1 << 16)
+#define SYS2_CLKSR_HWACC0_VAL(val) (((val) &
+#define SYS2_CLKSR_HWACC0_GET(val) (((val) & SYS2_CLKSR_HWACC0) >> 16)
+					 /* Clock Enable for SIF7 */
+#define SYS2_CLKSR_SIF7 (0x1 << 15)
+#define SYS2_CLKSR_SIF7_VAL(val) (((val) & 0x1) << 15)
+#define SYS2_CLKSR_SIF7_GET(val) (((val) & SYS2_CLKSR_SIF7) >> 15)
+					 /* Clock Enable for SIF6 */
+#define SYS2_CLKSR_SIF6 (0x1 << 14)
+#define SYS2_CLKSR_SIF6_VAL(val) (((val) & 0x1) << 14)
+#define SYS2_CLKSR_SIF6_GET(val) (((val) & SYS2_CLKSR_SIF6) >> 14)
+					 /* Clock Enable for SIF5 */
+#define SYS2_CLKSR_SIF5 (0x1 << 13)
+#define SYS2_CLKSR_SIF5_VAL(val) (((val) & 0x1) << 13)
+#define SYS2_CLKSR_SIF5_GET(val) (((val) & SYS2_CLKSR_SIF5) >> 13)
+					 /* Clock Enable for SIF4 */
+#define SYS2_CLKSR_SIF4 (0x1 << 12)
+#define SYS2_CLKSR_SIF4_VAL(val) (((val) & 0x1) << 12)
+#define SYS2_CLKSR_SIF4_GET(val) (((val) & SYS2_CLKSR_SIF4) >> 12)
+					 /* Clock Enable for SIF3 */
+#define SYS2_CLKSR_SIF3 (0x1 << 11)
+#define SYS2_CLKSR_SIF3_VAL(val) (((val) & 0x1) << 11)
+#define SYS2_CLKSR_SIF3_GET(val) (((val) & SYS2_CLKSR_SIF3) >> 11)
+/* Clock Enable for SIF2 */
+#define SYS2_CLKSR_SIF2 (0x1 << 10)
+#define SYS2_CLKSR_SIF2_VAL(val) (((val) & 0x1) << 10)
+#define SYS2_CLKSR_SIF2_GET(val) (((val) & SYS2_CLKSR_SIF2) >> 10)
+/* Clock Enable for SIF1 */
+#define SYS2_CLKSR_SIF1 (0x1 << 9)
+#define SYS2_CLKSR_SIF1_VAL(val) (((val) & 0x1) << 9)
+#define SYS2_CLKSR_SIF1_GET(val) (((val) & SYS2_CLKSR_SIF1) >> 9)
+/* Clock Enable for SIF0 */
+#define SYS2_CLKSR_SIF0 (0x1 << 8)
+#define SYS2_CLKSR_SIF0_VAL(val) (((val) & 0x1) << 8)
+#define SYS2_CLKSR_SIF0_GET(val) (((val) & SYS2_CLKSR_SIF0) >> 8)
+/* Clock Enable for DFEV7 */
+#define SYS2_CLKSR_DFEV7 (0x1 << 7)
+#define SYS2_CLKSR_DFEV7_VAL(val) (((val) & 0x1) << 7)
+#define SYS2_CLKSR_DFEV7_GET(val) (((val) & SYS2_CLKSR_DFEV7) >> 7)
+/* Clock Enable for DFEV6 */
+#define SYS2_CLKSR_DFEV6 (0x1 << 6)
+#define SYS2_CLKSR_DFEV6_VAL(val) (((val) & 0x1) << 6)
+#define SYS2_CLKSR_DFEV6_GET(val) (((val) & SYS2_CLKSR_DFEV6) >> 6)
+/* Clock Enable for DFEV5 */
+#define SYS2_CLKSR_DFEV5 (0x1 << 5)
+#define SYS2_CLKSR_DFEV5_VAL(val) (((val) & 0x1) << 5)
+#define SYS2_CLKSR_DFEV5_GET(val) (((val) & SYS2_CLKSR_DFEV5) >> 5)
+/* Clock Enable for DFEV4 */
+#define SYS2_CLKSR_DFEV4 (0x1 << 4)
+#define SYS2_CLKSR_DFEV4_VAL(val) (((val) & 0x1) << 4)
+#define SYS2_CLKSR_DFEV4_GET(val) (((val) & SYS2_CLKSR_DFEV4) >> 4)
+/* Clock Enable for DFEV3 */
+#define SYS2_CLKSR_DFEV3 (0x1 << 3)
+#define SYS2_CLKSR_DFEV3_VAL(val) (((val) & 0x1) << 3)
+#define SYS2_CLKSR_DFEV3_GET(val) (((val) & SYS2_CLKSR_DFEV3) >> 3)
+/* Clock Enable for DFEV2 */
+#define SYS2_CLKSR_DFEV2 (0x1 << 2)
+#define SYS2_CLKSR_DFEV2_VAL(val) (((val) & 0x1) << 2)
+#define SYS2_CLKSR_DFEV2_GET(val) (((val) & SYS2_CLKSR_DFEV2) >> 2)
+/* Clock Enable for DFEV1 */
+#define SYS2_CLKSR_DFEV1 (0x1 << 1)
+#define SYS2_CLKSR_DFEV1_VAL(val) (((val) & 0x1) << 1)
+#define SYS2_CLKSR_DFEV1_GET(val) (((val) & SYS2_CLKSR_DFEV1) >> 1)
+/* Clock Enable for DFEV0 */
+#define SYS2_CLKSR_DFEV0 (0x1)
+#define SYS2_CLKSR_DFEV0_VAL(val) (((val) & 0x1))
+#define SYS2_CLKSR_DFEV0_GET(val) ((val) & SYS2_CLKSR_DFEV0)
+
+/*******************************************************************************
+ * SYS2 Clock Enable Register
+ ******************************************************************************/
+
+/* Clock Enable Request for PORT4 */
+#define SYS2_CLKENR_PORT4 (0x1 << 27)
+#define SYS2_CLKENR_PORT4_VAL(val) (((val) & 0x1) << 27)
+#define SYS2_CLKENR_PORT4_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_PORT4) | ((val & 0x1) << 27))
+/* Clock Enable Request for HWSYNC */
+#define SYS2_CLKENR_HWSYNC (0x1 << 26)
+#define SYS2_CLKENR_HWSYNC_VAL(val) (((val) & 0x1) << 26)
+#define SYS2_CLKENR_HWSYNC_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_HWSYNC) | ((val & 0x1) << 26))
+/* Clock Enable Request for MBS */
+#define SYS2_CLKENR_MBS (0x1 << 25)
+#define SYS2_CLKENR_MBS_VAL(val) (((val) & 0x1) << 25)
+#define SYS2_CLKENR_MBS_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_MBS) | ((val & 0x1) << 25))
+/* Clock Enable Request for SWINT */
+#define SYS2_CLKENR_SWINT (0x1 << 24)
+#define SYS2_CLKENR_SWINT_VAL(val) (((val) & 0x1) << 24)
+#define SYS2_CLKENR_SWINT_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_SWINT) | ((val & 0x1) << 24))
+/* Clock Enable Request for HWACC3 */
+#define SYS2_CLKENR_HWACC3 (0x1 << 19)
+#define SYS2_CLKENR_HWACC3_VAL(val) (((val) & 0x1) << 19)
+#define SYS2_CLKENR_HWACC3_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_HWACC3) | ((val & 0x1) << 19))
+/* Clock Enable Request for HWACC2 */
+#define SYS2_CLKENR_HWACC2 (0x1 << 18)
+#define SYS2_CLKENR_HWACC2_VAL(val) (((val) & 0x1) << 18)
+#define SYS2_CLKENR_HWACC2_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_HWACC2) | ((val & 0x1) << 18))
+/* Clock Enable Request for HWACC1 */
+#define SYS2_CLKENR_HWACC1 (0x1 << 17)
+#define SYS2_CLKENR_HWACC1_VAL(val) (((val) & 0x1) << 17)
+#define SYS2_CLKENR_HWACC1_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_HWACC1) | ((val & 0x1) << 17))
+/* Clock Enable Request for HWACC0 */
+#define SYS2_CLKENR_HWACC0 (0x1 << 16)
+#define SYS2_CLKENR_HWACC0_VAL(val) (((val) & 0x1) << 16)
+#define SYS2_CLKENR_HWACC0_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_HWACC0) | ((val & 0x1) << 16))
+/* Clock Enable Request for SIF7 */
+#define SYS2_CLKENR_SIF7 (0x1 << 15)
+#define SYS2_CLKENR_SIF7_VAL(val) (((val) & 0x1) << 15)
+#define SYS2_CLKENR_SIF7_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_SIF7) | ((val & 0x1) << 15))
+/* Clock Enable Request for SIF6 */
+#define SYS2_CLKENR_SIF6 (0x1 << 14)
+#define SYS2_CLKENR_SIF6_VAL(val) (((val) & 0x1) << 14)
+#define SYS2_CLKENR_SIF6_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_SIF6) | ((val & 0x1) << 14))
+/* Clock Enable Request for SIF5 */
+#define SYS2_CLKENR_SIF5 (0x1 << 13)
+#define SYS2_CLKENR_SIF5_VAL(val) (((val) & 0x1) << 13)
+#define SYS2_CLKENR_SIF5_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_SIF5) | ((val & 0x1) << 13))
+/* Clock Enable Request for SIF4 */
+#define SYS2_CLKENR_SIF4 (0x1 << 12)
+#define SYS2_CLKENR_SIF4_VAL(val) (((val) & 0x1) << 12)
+#define SYS2_CLKENR_SIF4_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_SIF4) | ((val & 0x1) << 12))
+/* Clock Enable Request for SIF3 */
+#define SYS2_CLKENR_SIF3 (0x1 << 11)
+#define SYS2_CLKENR_SIF3_VAL(val) (((val) & 0x1) << 11)
+#define SYS2_CLKENR_SIF3_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_SIF3) | ((val & 0x1) << 11))
+/* Clock Enable Request for SIF2 */
+#define SYS2_CLKENR_SIF2 (0x1 << 10)
+#define SYS2_CLKENR_SIF2_VAL(val) (((val) & 0x1) << 10)
+#define SYS2_CLKENR_SIF2_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_SIF2) | ((val & 0x1) << 10))
+/* Clock Enable Request for SIF1 */
+#define SYS2_CLKENR_SIF1 (0x1 << 9)
+#define SYS2_CLKENR_SIF1_VAL(val) (((val) & 0x1) << 9)
+#define SYS2_CLKENR_SIF1_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_SIF1) | ((val & 0x1) << 9))
+/* Clock Enable Request for SIF0 */
+#define SYS2_CLKENR_SIF0 (0x1 << 8)
+#define SYS2_CLKENR_SIF0_VAL(val) (((val) & 0x1) << 8)
+#define SYS2_CLKENR_SIF0_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_SIF0) | ((val & 0x1) << 8))
+/* Clock Enable Request for DFEV7 */
+#define SYS2_CLKENR_DFEV7 (0x1 << 7)
+#define SYS2_CLKENR_DFEV7_VAL(val) (((val) & 0x1) << 7)
+#define SYS2_CLKENR_DFEV7_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_DFEV7) | ((val & 0x1) << 7))
+/* Clock Enable Request for DFEV6 */
+#define SYS2_CLKENR_DFEV6 (0x1 << 6)
+#define SYS2_CLKENR_DFEV6_VAL(val) (((val) & 0x1) << 6)
+#define SYS2_CLKENR_DFEV6_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_DFEV6) | ((val & 0x1) << 6))
+/* Clock Enable Request for DFEV5 */
+#define SYS2_CLKENR_DFEV5 (0x1 << 5)
+#define SYS2_CLKENR_DFEV5_VAL(val) (((val) & 0x1) << 5)
+#define SYS2_CLKENR_DFEV5_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_DFEV5) | ((val & 0x1) << 5))
+/* Clock Enable Request for DFEV4 */
+#define SYS2_CLKENR_DFEV4 (0x1 << 4)
+#define SYS2_CLKENR_DFEV4_VAL(val) (((val) & 0x1) << 4)
+#define SYS2_CLKENR_DFEV4_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_DFEV4) | ((val & 0x1) << 4))
+/* Clock Enable Request for DFEV3 */
+#define SYS2_CLKENR_DFEV3 (0x1 << 3)
+#define SYS2_CLKENR_DFEV3_VAL(val) (((val) & 0x1) << 3)
+#define SYS2_CLKENR_DFEV3_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_DFEV3) | ((val & 0x1) << 3))
+/* Clock Enable Request for DFEV2 */
+#define SYS2_CLKENR_DFEV2 (0x1 << 2)
+#define SYS2_CLKENR_DFEV2_VAL(val) (((val) & 0x1) << 2)
+#define SYS2_CLKENR_DFEV2_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_DFEV2) | ((val & 0x1) << 2))
+/* Clock Enable Request for DFEV1 */
+#define SYS2_CLKENR_DFEV1 (0x1 << 1)
+#define SYS2_CLKENR_DFEV1_VAL(val) (((val) & 0x1) << 1)
+#define SYS2_CLKENR_DFEV1_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_DFEV1) | ((val & 0x1) << 1))
+/* Clock Enable Request for DFEV0 */
+#define SYS2_CLKENR_DFEV0 (0x1)
+#define SYS2_CLKENR_DFEV0_VAL(val) (((val) & 0x1))
+#define SYS2_CLKENR_DFEV0_SET (reg,val) (reg) = ((reg & ~SYS2_CLKENR_DFEV0) | ((val & 0x1)))
+
+/*******************************************************************************
+ * SYS2 Clock Clear Register
+ ******************************************************************************/
+
+/* Clock Disable Request for PORT4 */
+#define SYS2_CLKCLR_PORT4 (0x1 << 27)
+#define SYS2_CLKCLR_PORT4_VAL(val) (((val) & 0x1) << 27)
+#define SYS2_CLKCLR_PORT4_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_PORT4) | ((val & 0x1) << 27))
+/* Clock Disable Request for HWSYNC */
+#define SYS2_CLKCLR_HWSYNC (0x1 << 26)
+#define SYS2_CLKCLR_HWSYNC_VAL(val) (((val) & 0x1) << 26)
+#define SYS2_CLKCLR_HWSYNC_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_HWSYNC) | ((val & 0x1) << 26))
+/* Clock Disable Request for MBS */
+#define SYS2_CLKCLR_MBS (0x1 << 25)
+#define SYS2_CLKCLR_MBS_VAL(val) (((val) & 0x1) << 25)
+#define SYS2_CLKCLR_MBS_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_MBS) | ((val & 0x1) << 25))
+/* Clock Disable Request for SWINT */
+#define SYS2_CLKCLR_SWINT (0x1 << 24)
+#define SYS2_CLKCLR_SWINT_VAL(val) (((val) & 0x1) << 24)
+#define SYS2_CLKCLR_SWINT_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_SWINT) | ((val & 0x1) << 24))
+/* Clock Disable Request for HWACC3 */
+#define SYS2_CLKCLR_HWACC3 (0x1 << 19)
+#define SYS2_CLKCLR_HWACC3_VAL(val) (((val) & 0x1) << 19)
+#define SYS2_CLKCLR_HWACC3_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_HWACC3) | ((val & 0x1) << 19))
+/* Clock Disable Request for HWACC2 */
+#define SYS2_CLKCLR_HWACC2 (0x1 << 18)
+#define SYS2_CLKCLR_HWACC2_VAL(val) (((val) & 0x1) << 18)
+#define SYS2_CLKCLR_HWACC2_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_HWACC2) | ((val & 0x1) << 18))
+/* Clock Disable Request for HWACC1 */
+#define SYS2_CLKCLR_HWACC1 (0x1 << 17)
+#define SYS2_CLKCLR_HWACC1_VAL(val) (((val) & 0x1) << 17)
+#define SYS2_CLKCLR_HWACC1_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_HWACC1) | ((val & 0x1) << 17))
+/* Clock Disable Request for HWACC0 */
+#define SYS2_CLKCLR_HWACC0 (0x1 << 16)
+#define SYS2_CLKCLR_HWACC0_VAL(val) (((val) & 0x1) << 16)
+#define SYS2_CLKCLR_HWACC0_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_HWACC0) | ((val & 0x1) << 16))
+/* Clock Disable Request for SIF7 */
+#define SYS2_CLKCLR_SIF7 (0x1 << 15)
+#define SYS2_CLKCLR_SIF7_VAL(val) (((val) & 0x1) << 15)
+#define SYS2_CLKCLR_SIF7_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_SIF7) | ((val & 0x1) << 15))
+/* Clock Disable Request for SIF6 */
+#define SYS2_CLKCLR_SIF6 (0x1 << 14)
+#define SYS2_CLKCLR_SIF6_VAL(val) (((val) & 0x1) << 14)
+#define SYS2_CLKCLR_SIF6_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_SIF6) | ((val & 0x1) << 14))
+/* Clock Disable Request for SIF5 */
+#define SYS2_CLKCLR_SIF5 (0x1 << 13)
+#define SYS2_CLKCLR_SIF5_VAL(val) (((val) & 0x1) << 13)
+#define SYS2_CLKCLR_SIF5_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_SIF5) | ((val & 0x1) << 13))
+/* Clock Disable Request for SIF4 */
+#define SYS2_CLKCLR_SIF4 (0x1 << 12)
+#define SYS2_CLKCLR_SIF4_VAL(val) (((val) & 0x1) << 12)
+#define SYS2_CLKCLR_SIF4_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_SIF4) | ((val & 0x1) << 12))
+/* Clock Disable Request for SIF3 */
+#define SYS2_CLKCLR_SIF3 (0x1 << 11)
+#define SYS2_CLKCLR_SIF3_VAL(val) (((val) & 0x1) << 11)
+#define SYS2_CLKCLR_SIF3_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_SIF3) | ((val & 0x1) << 11))
+/* Clock Disable Request for SIF2 */
+#define SYS2_CLKCLR_SIF2 (0x1 << 10)
+#define SYS2_CLKCLR_SIF2_VAL(val) (((val) & 0x1) << 10)
+#define SYS2_CLKCLR_SIF2_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_SIF2) | ((val & 0x1) << 10))
+/* Clock Disable Request for SIF1 */
+#define SYS2_CLKCLR_SIF1 (0x1 << 9)
+#define SYS2_CLKCLR_SIF1_VAL(val) (((val) & 0x1) << 9)
+#define SYS2_CLKCLR_SIF1_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_SIF1) | ((val & 0x1) << 9))
+/* Clock Disable Request for SIF0 */
+#define SYS2_CLKCLR_SIF0 (0x1 << 8)
+#define SYS2_CLKCLR_SIF0_VAL(val) (((val) & 0x1) << 8)
+#define SYS2_CLKCLR_SIF0_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_SIF0) | ((val & 0x1) << 8))
+/* Clock Disable Request for DFEV7 */
+#define SYS2_CLKCLR_DFEV7 (0x1 << 7)
+#define SYS2_CLKCLR_DFEV7_VAL(val) (((val) & 0x1) << 7)
+#define SYS2_CLKCLR_DFEV7_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_DFEV7) | ((val & 0x1) << 7))
+/* Clock Disable Request for DFEV6 */
+#define SYS2_CLKCLR_DFEV6 (0x1 << 6)
+#define SYS2_CLKCLR_DFEV6_VAL(val) (((val) & 0x1) << 6)
+#define SYS2_CLKCLR_DFEV6_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_DFEV6) | ((val & 0x1) << 6))
+/* Clock Disable Request for DFEV5 */
+#define SYS2_CLKCLR_DFEV5 (0x1 << 5)
+#define SYS2_CLKCLR_DFEV5_VAL(val) (((val) & 0x1) << 5)
+#define SYS2_CLKCLR_DFEV5_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_DFEV5) | ((val & 0x1) << 5))
+/* Clock Disable Request for DFEV4 */
+#define SYS2_CLKCLR_DFEV4 (0x1 << 4)
+#define SYS2_CLKCLR_DFEV4_VAL(val) (((val) & 0x1) << 4)
+#define SYS2_CLKCLR_DFEV4_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_DFEV4) | ((val & 0x1) << 4))
+/* Clock Disable Request for DFEV3 */
+#define SYS2_CLKCLR_DFEV3 (0x1 << 3)
+#define SYS2_CLKCLR_DFEV3_VAL(val) (((val) & 0x1) << 3)
+#define SYS2_CLKCLR_DFEV3_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_DFEV3) | ((val & 0x1) << 3))
+/* Clock Disable Request for DFEV2 */
+#define SYS2_CLKCLR_DFEV2 (0x1 << 2)
+#define SYS2_CLKCLR_DFEV2_VAL(val) (((val) & 0x1) << 2)
+#define SYS2_CLKCLR_DFEV2_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_DFEV2) | ((val & 0x1) << 2))
+/* Clock Disable Request for DFEV1 */
+#define SYS2_CLKCLR_DFEV1 (0x1 << 1)
+#define SYS2_CLKCLR_DFEV1_VAL(val) (((val) & 0x1) << 1)
+#define SYS2_CLKCLR_DFEV1_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_DFEV1) | ((val & 0x1) << 1))
+/* Clock Disable Request for DFEV0 */
+#define SYS2_CLKCLR_DFEV0 (0x1)
+#define SYS2_CLKCLR_DFEV0_VAL(val) (((val) & 0x1))
+#define SYS2_CLKCLR_DFEV0_SET (reg,val) (reg) = ((reg & ~SYS2_CLKCLR_DFEV0) | ((val & 0x1)))
+
+/*******************************************************************************
+ * SYS2 Reset Status Register
+ ******************************************************************************/
+
+/* HWACC3 Reset */
+#define SYS2_RSR_HWACC3 (0x1 << 11)
+#define SYS2_RSR_HWACC3_VAL(val) (((val) & 0x1) << 11)
+#define SYS2_RSR_HWACC3_GET(val) (((val) & SYS2_RSR_HWACC3) >> 11)
+/* HWACC2 Reset */
+#define SYS2_RSR_HWACC2 (0x1 << 10)
+#define SYS2_RSR_HWACC2_VAL(val) (((val) & 0x1) << 10)
+#define SYS2_RSR_HWACC2_GET(val) (((val) & SYS2_RSR_HWACC2) >> 10)
+/* HWACC1 Reset */
+#define SYS2_RSR_HWACC1 (0x1 << 9)
+#define SYS2_RSR_HWACC1_VAL(val) (((val) & 0x1) << 9)
+#define SYS2_RSR_HWACC1_GET(val) (((val) & SYS2_RSR_HWACC1) >> 9)
+/* HWACC0 Reset */
+#define SYS2_RSR_HWACC0 (0x1 << 8)
+#define SYS2_RSR_HWACC0_VAL(val) (((val) & 0x1) << 8)
+#define SYS2_RSR_HWACC0_GET(val) (((val) & SYS2_RSR_HWACC0) >> 8)
+/* DFEV7 Reset */
+#define SYS2_RSR_DFEV7 (0x1 << 7)
+#define SYS2_RSR_DFEV7_VAL(val) (((val) & 0x1) << 7)
+#define SYS2_RSR_DFEV7_GET(val) (((val) & SYS2_RSR_DFEV7) >> 7)
+/* DFEV6 Reset */
+#define SYS2_RSR_DFEV6 (0x1 << 6)
+#define SYS2_RSR_DFEV6_VAL(val) (((val) & 0x1) << 6)
+#define SYS2_RSR_DFEV6_GET(val) (((val) & SYS2_RSR_DFEV6) >> 6)
+/* DFEV5 Reset */
+#define SYS2_RSR_DFEV5 (0x1 << 5)
+#define SYS2_RSR_DFEV5_VAL(val) (((val) & 0x1) << 5)
+#define SYS2_RSR_DFEV5_GET(val) (((val) & SYS2_RSR_DFEV5) >> 5)
+/* DFEV4 Reset */
+#define SYS2_RSR_DFEV4 (0x1 << 4)
+#define SYS2_RSR_DFEV4_VAL(val) (((val) & 0x1) << 4)
+#define SYS2_RSR_DFEV4_GET(val) (((val) & SYS2_RSR_DFEV4) >> 4)
+/* DFEV3 Reset */
+#define SYS2_RSR_DFEV3 (0x1 << 3)
+#define SYS2_RSR_DFEV3_VAL(val) (((val) & 0x1) << 3)
+#define SYS2_RSR_DFEV3_GET(val) (((val) & SYS2_RSR_DFEV3) >> 3)
+/* DFEV2 Reset */
+#define SYS2_RSR_DFEV2 (0x1 << 2)
+#define SYS2_RSR_DFEV2_VAL(val) (((val) & 0x1) << 2)
+#define SYS2_RSR_DFEV2_GET(val) (((val) & SYS2_RSR_DFEV2) >> 2)
+/* DFEV1 Reset */
+#define SYS2_RSR_DFEV1 (0x1 << 1)
+#define SYS2_RSR_DFEV1_VAL(val) (((val) & 0x1) << 1)
+#define SYS2_RSR_DFEV1_GET(val) (((val) & SYS2_RSR_DFEV1) >> 1)
+/* DFEV0 Reset */
+#define SYS2_RSR_DFEV0 (0x1)
+#define SYS2_RSR_DFEV0_VAL(val) (((val) & 0x1))
+#define SYS2_RSR_DFEV0_GET(val) ((val) & SYS2_RSR_DFEV0)
+
+/******************************************************************************
+ * SYS2 Reset Request Register
+ ******************************************************************************/
+
+/* HWACC3 Reset Request */
+#define SYS2_RREQR_HWACC3 (0x1 << 11)
+#define SYS2_RREQR_HWACC3_VAL(val) (((val) & 0x1) << 11)
+#define SYS2_RREQR_HWACC3_SET (reg,val) (reg) = ((reg & ~SYS2_RREQR_HWACC3) | ((val & 0x1) << 11))
+/* HWACC2 Reset Request */
+#define SYS2_RREQR_HWACC2 (0x1 << 10)
+#define SYS2_RREQR_HWACC2_VAL(val) (((val) & 0x1) << 10)
+#define SYS2_RREQR_HWACC2_SET (reg,val) (reg) = ((reg & ~SYS2_RREQR_HWACC2) | ((val & 0x1) << 10))
+/* HWACC1 Reset Request */
+#define SYS2_RREQR_HWACC1 (0x1 << 9)
+#define SYS2_RREQR_HWACC1_VAL(val) (((val) & 0x1) << 9)
+#define SYS2_RREQR_HWACC1_SET (reg,val) (reg) = ((reg & ~SYS2_RREQR_HWACC1) | ((val & 0x1) << 9))
+/* HWACC0 Reset Request */
+#define SYS2_RREQR_HWACC0 (0x1 << 8)
+#define SYS2_RREQR_HWACC0_VAL(val) (((val) & 0x1) << 8)
+#define SYS2_RREQR_HWACC0_SET (reg,val) (reg) = ((reg & ~SYS2_RREQR_HWACC0) | ((val & 0x1) << 8))
+/* DFEV7 Reset Request */
+#define SYS2_RREQR_DFEV7 (0x1 << 7)
+#define SYS2_RREQR_DFEV7_VAL(val) (((val) & 0x1) << 7)
+#define SYS2_RREQR_DFEV7_SET (reg,val) (reg) = ((reg & ~SYS2_RREQR_DFEV7) | ((val & 0x1) << 7))
+/* DFEV6 Reset Request */
+#define SYS2_RREQR_DFEV6 (0x1 << 6)
+#define SYS2_RREQR_DFEV6_VAL(val) (((val) & 0x1) << 6)
+#define SYS2_RREQR_DFEV6_SET (reg,val) (reg) = ((reg & ~SYS2_RREQR_DFEV6) | ((val & 0x1) << 6))
+/* DFEV5 Reset Request */
+#define SYS2_RREQR_DFEV5 (0x1 << 5)
+#define SYS2_RREQR_DFEV5_VAL(val) (((val) & 0x1) << 5)
+#define SYS2_RREQR_DFEV5_SET (reg,val) (reg) = ((reg & ~SYS2_RREQR_DFEV5) | ((val & 0x1) << 5))
+/* DFEV4 Reset Request */
+#define SYS2_RREQR_DFEV4 (0x1 << 4)
+#define SYS2_RREQR_DFEV4_VAL(val) (((val) & 0x1) << 4)
+#define SYS2_RREQR_DFEV4_SET (reg,val) (reg) = ((reg & ~SYS2_RREQR_DFEV4) | ((val & 0x1) << 4))
+/* DFEV3 Reset Request */
+#define SYS2_RREQR_DFEV3 (0x1 << 3)
+#define SYS2_RREQR_DFEV3_VAL(val) (((val) & 0x1) << 3)
+#define SYS2_RREQR_DFEV3_SET (reg,val) (reg) = ((reg & ~SYS2_RREQR_DFEV3) | ((val & 0x1) << 3))
+/* DFEV2 Reset Request */
+#define SYS2_RREQR_DFEV2 (0x1 << 2)
+#define SYS2_RREQR_DFEV2_VAL(val) (((val) & 0x1) << 2)
+#define SYS2_RREQR_DFEV2_SET (reg,val) (reg) = ((reg & ~SYS2_RREQR_DFEV2) | ((val & 0x1) << 2))
+/* DFEV1 Reset Request */
+#define SYS2_RREQR_DFEV1 (0x1 << 1)
+#define SYS2_RREQR_DFEV1_VAL(val) (((val) & 0x1) << 1)
+#define SYS2_RREQR_DFEV1_SET (reg,val) (reg) = ((reg & ~SYS2_RREQR_DFEV1) | ((val & 0x1) << 1))
+/* DFEV0 Reset Request */
+#define SYS2_RREQR_DFEV0 (0x1)
+#define SYS2_RREQR_DFEV0_VAL(val) (((val) & 0x1))
+#define SYS2_RREQR_DFEV0_SET (reg,val) (reg) = ((reg & ~SYS2_RREQR_DFEV0) | ((val & 0x1)))
+
+/*******************************************************************************
+ * SYS2 Reset Release Register
+ ******************************************************************************/
+
+/* HWACC3 Reset Release */
+#define SYS2_RRLSR_HWACC3 (0x1 << 11)
+#define SYS2_RRLSR_HWACC3_VAL(val) (((val) & 0x1) << 11)
+#define SYS2_RRLSR_HWACC3_SET (reg,val) (reg) = ((reg & ~SYS2_RRLSR_HWACC3) | ((val & 0x1) << 11))
+/* HWACC2 Reset Release */
+#define SYS2_RRLSR_HWACC2 (0x1 << 10)
+#define SYS2_RRLSR_HWACC2_VAL(val) (((val) & 0x1) << 10)
+#define SYS2_RRLSR_HWACC2_SET (reg,val) (reg) = ((reg & ~SYS2_RRLSR_HWACC2) | ((val & 0x1) << 10))
+/* HWACC1 Reset Release */
+#define SYS2_RRLSR_HWACC1 (0x1 << 9)
+#define SYS2_RRLSR_HWACC1_VAL(val) (((val) & 0x1) << 9)
+#define SYS2_RRLSR_HWACC1_SET (reg,val) (reg) = ((reg & ~SYS2_RRLSR_HWACC1) | ((val & 0x1) << 9))
+/* HWACC0 Reset Release */
+#define SYS2_RRLSR_HWACC0 (0x1 << 8)
+#define SYS2_RRLSR_HWACC0_VAL(val) (((val) & 0x1) << 8)
+#define SYS2_RRLSR_HWACC0_SET (reg,val) (reg) = ((reg & ~SYS2_RRLSR_HWACC0) | ((val & 0x1) << 8))
+/* DFEV7 Reset Release */
+#define SYS2_RRLSR_DFEV7 (0x1 << 7)
+#define SYS2_RRLSR_DFEV7_VAL(val) (((val) & 0x1) << 7)
+#define SYS2_RRLSR_DFEV7_SET (reg,val) (reg) = ((reg & ~SYS2_RRLSR_DFEV7) | ((val & 0x1) << 7))
+/* DFEV6 Reset Release */
+#define SYS2_RRLSR_DFEV6 (0x1 << 6)
+#define SYS2_RRLSR_DFEV6_VAL(val) (((val) & 0x1) << 6)
+#define SYS2_RRLSR_DFEV6_SET (reg,val) (reg) = ((reg & ~SYS2_RRLSR_DFEV6) | ((val & 0x1) << 6))
+/* DFEV5 Reset Release */
+#define SYS2_RRLSR_DFEV5 (0x1 << 5)
+#define SYS2_RRLSR_DFEV5_VAL(val) (((val) & 0x1) << 5)
+#define SYS2_RRLSR_DFEV5_SET (reg,val) (reg) = ((reg & ~SYS2_RRLSR_DFEV5) | ((val & 0x1) << 5))
+/* DFEV4 Reset Release */
+#define SYS2_RRLSR_DFEV4 (0x1 << 4)
+#define SYS2_RRLSR_DFEV4_VAL(val) (((val) & 0x1) << 4)
+#define SYS2_RRLSR_DFEV4_SET (reg,val) (reg) = ((reg & ~SYS2_RRLSR_DFEV4) | ((val & 0x1) << 4))
+/* DFEV3 Reset Release */
+#define SYS2_RRLSR_DFEV3 (0x1 << 3)
+#define SYS2_RRLSR_DFEV3_VAL(val) (((val) & 0x1) << 3)
+#define SYS2_RRLSR_DFEV3_SET (reg,val) (reg) = ((reg & ~SYS2_RRLSR_DFEV3) | ((val & 0x1) << 3))
+/* DFEV2 Reset Release */
+#define SYS2_RRLSR_DFEV2 (0x1 << 2)
+#define SYS2_RRLSR_DFEV2_VAL(val) (((val) & 0x1) << 2)
+#define SYS2_RRLSR_DFEV2_SET (reg,val) (reg) = ((reg & ~SYS2_RRLSR_DFEV2) | ((val & 0x1) << 2))
+/* DFEV1 Reset Release */
+#define SYS2_RRLSR_DFEV1 (0x1 << 1)
+#define SYS2_RRLSR_DFEV1_VAL(val) (((val) & 0x1) << 1)
+#define SYS2_RRLSR_DFEV1_SET (reg,val) (reg) = ((reg & ~SYS2_RRLSR_DFEV1) | ((val & 0x1) << 1))
+/* DFEV0 Reset Release */
+#define SYS2_RRLSR_DFEV0 (0x1)
+#define SYS2_RRLSR_DFEV0_VAL(val) (((val) & 0x1))
+#define SYS2_RRLSR_DFEV0_SET (reg,val) (reg) = ((reg & ~SYS2_RRLSR_DFEV0) | ((val & 0x1)))
+
+#endif /* __SYS2_H */
+
--- /dev/null
+++ b/arch/mips/include/asm/mach-lantiq/svip/sysctrl.h
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (C) 2010 Thomas Langer, Lantiq Deutschland */
+/* Copyright (C) 2018 Intel Corporation */
+
+#ifndef __SVIP_SYSCTRL_H
+#define __SVIP_SYSCTRL_H
+
+#include <svip/lantiq_soc.h>
+
+#endif /* __SVIP_SYSCTRL_H */
--- a/arch/mips/lantiq/Kconfig
+++ b/arch/mips/lantiq/Kconfig
@@ -23,6 +23,11 @@ config SOC_FALCON
 	bool "FALCON"
 	select PINCTRL_FALCON
 
+config SOC_SVIP
+	bool "SVIP"
+	select PINCTRL_SVIP
+	select SYS_SUPPORTS_LITTLE_ENDIAN
+
 endchoice
 
 choice
--- a/arch/mips/lantiq/Makefile
+++ b/arch/mips/lantiq/Makefile
@@ -11,3 +11,4 @@ obj-$(CONFIG_VPE_SOFTDOG) += softdog_vpe
 
 obj-$(CONFIG_SOC_TYPE_XWAY) += xway/
 obj-$(CONFIG_SOC_FALCON) += falcon/
+obj-$(CONFIG_SOC_SVIP) += svip/
--- a/arch/mips/lantiq/Platform
+++ b/arch/mips/lantiq/Platform
@@ -7,3 +7,4 @@ cflags-$(CONFIG_LANTIQ)		+= -I$(srctree)
 load-$(CONFIG_LANTIQ)		= 0xffffffff80002000
 cflags-$(CONFIG_SOC_TYPE_XWAY)	+= -I$(srctree)/arch/mips/include/asm/mach-lantiq/xway
 cflags-$(CONFIG_SOC_FALCON)	+= -I$(srctree)/arch/mips/include/asm/mach-lantiq/falcon
+cflags-$(CONFIG_SOC_SVIP)	+= -I$(srctree)/arch/mips/include/asm/mach-lantiq/svip
--- a/arch/mips/lantiq/irq.c
+++ b/arch/mips/lantiq/irq.c
@@ -1,11 +1,7 @@
-/*
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 as published
- *  by the Free Software Foundation.
- *
- * Copyright (C) 2010 John Crispin <john@phrozen.org>
- * Copyright (C) 2010 Thomas Langer <thomas.langer@lantiq.com>
- */
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2010 John Crispin <john@phrozen.org> */
+/* Copyright (C) 2010 Thomas Langer <thomas.langer@lantiq.com> */
+/* Copyright (C) 2018 Intel Corporation */
 
 #include <linux/interrupt.h>
 #include <linux/ioport.h>
@@ -21,6 +17,7 @@
 
 #include <lantiq_soc.h>
 #include <irq.h>
+#include <svip/ebu_reg.h>
 
 /* register definitions - internal irqs */
 #define LTQ_ICU_IM0_ISR		0x0000
@@ -38,7 +35,7 @@
 #define LTQ_EIU_EXIN_INEN	0x000C
 
 /* number of external interrupts */
-#define MAX_EIU			6
+#define MAX_EIU			17
 
 /* the performance counter */
 #define LTQ_PERF_IRQ		(INT_NUM_IM4_IRL0 + 31)
--- /dev/null
+++ b/arch/mips/lantiq/svip/Makefile
@@ -0,0 +1 @@
+obj-y := prom.o reset.o sysctrl.o
--- /dev/null
+++ b/arch/mips/lantiq/svip/prom.c
@@ -0,0 +1,82 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2012 Thomas Langer <thomas.langer@lantiq.com> */
+/* Copyright (C) 2012 John Crispin <blogic@openwrt.org> */
+/* Copyright (C) 2018 Intel Corporation */
+
+#include <linux/kernel.h>
+#include <asm/cacheflush.h>
+#include <asm/traps.h>
+#include <asm/io.h>
+#include <asm/bootinfo.h>
+
+#include <lantiq_soc.h>
+
+#include "../prom.h"
+
+#define SOC_SVIP	"SVIP"
+#define SOC_SVIP_D	"SVIP-D"
+
+#define COMP_SVIP	"lantiq,svip"
+
+/* reset, nmi and ejtag exception vectors */
+/*
+#define BOOT_REG_BASE	(KSEG1 | 0x1F200000)
+#define BOOT_RVEC	(BOOT_REG_BASE | 0x00)
+#define BOOT_NVEC	(BOOT_REG_BASE | 0x04)
+#define BOOT_EVEC	(BOOT_REG_BASE | 0x08)
+*/
+/*
+void __init ltq_soc_nmi_setup(void)
+{
+
+	extern void (*nmi_handler)(void);
+
+	ltq_w32((unsigned long)&nmi_handler, (void *)BOOT_NVEC);
+}
+*/
+/*
+void __init ltq_soc_ejtag_setup(void)
+{
+	extern void (*ejtag_debug_handler)(void);
+
+	ltq_w32((unsigned long)&ejtag_debug_handler, (void *)BOOT_EVEC);
+}
+*/
+void __init ltq_soc_detect(struct ltq_soc_info *i)
+{
+	u32 fuse, chipid;
+	struct cpuinfo_mips *c = &current_cpu_data;
+	/* disable L2 cache, because it is in use by FW !*/
+	c->scache.flags |= MIPS_CACHE_NOT_PRESENT;
+
+	chipid = ltq_r32(SVIP_CHIPID);
+	fuse = ltq_r32(SVIP_FUSE);
+	i->partnum = STATUS_CHIPID_PART_NUMBER_GET(chipid);
+	i->rev = STATUS_CHIPID_VERSION_GET(chipid);
+	i->compatible = COMP_SVIP;
+	i->type = SOC_TYPE_SVIP;
+	sprintf(i->rev_type, "1.%d", i->rev);
+	switch (i->partnum) {
+	case SOC_ID_SVIP:
+	case SOC_ID_SVIPx:
+		if (STATUS_FUSE_DEU_DEU_GET(fuse))
+			i->name = SOC_SVIP_D;
+		else
+			i->name = SOC_SVIP;
+		break;
+	default:
+		printk(KERN_ERR "unknown partnum : 0x%08X\n", i->partnum);
+		unreachable();
+		break;
+	}
+/*
+	board_nmi_handler_setup = ltq_soc_nmi_setup;
+	board_ejtag_handler_setup = ltq_soc_ejtag_setup;
+*/
+}
+
+unsigned int* ltq_get_cp1_base(void)
+{
+	return (unsigned int *)KSEG1ADDR(boot_mem_map.map[0].size);
+}
+EXPORT_SYMBOL(ltq_get_cp1_base);
--- /dev/null
+++ b/arch/mips/lantiq/svip/reset.c
@@ -0,0 +1,114 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2012 Thomas Langer <thomas.langer@lantiq.com> */
+/* Copyright (C) 2012 John Crispin <blogic@openwrt.org> */
+/* Copyright (C) 2018 Intel Corporation */
+
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/pm.h>
+#include <asm/reboot.h>
+#include <linux/export.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <lantiq_soc.h>
+
+static unsigned long svip_board_reset_reg_addr = 0;
+static unsigned long svip_board_reset_value = 0;
+
+#define EBU_ADDR_SEL_2	0x0028
+#define EBU_CON_2	0x0068
+#define L2_SPRAM_BASE 0x1F1E8000
+#define SYS1_RREQR 0x0044
+#define SYS1_RRLSR 0x0048
+#define SYS1_CLKCLR 0x0008
+#define SYS1_RBTR 0x004C
+
+/* to avoid problems with the gcc "__builtin_unreachable", change definition here! */
+#undef unreachable
+#define unreachable()	do { } while(1)
+
+/* allow platform code to find out what source we booted from */
+unsigned char ltq_boot_select(void)
+{
+	return 0;
+}
+
+/* allow the watchdog driver to find out what the boot reason was */
+int ltq_reset_cause(void)
+{
+	return 0;
+} 
+
+static void machine_restart_toggle_pin(char *command)
+{
+	local_irq_disable();
+	ltq_ebu_w32(0x120000f1, EBU_ADDR_SEL_2);
+#ifdef CONFIG_CPU_LITTLE_ENDIAN
+	ltq_ebu_w32(0x4027ff, EBU_CON_2);
+#else
+	ltq_ebu_w32(0x404027ff, EBU_CON_2);
+#endif
+	if (svip_board_reset_reg_addr)
+		/* We just use the CPLD function to reset the entire system as a
+		workaround for the switch reset problem described in the errata
+		*/
+		iowrite8((u8) svip_board_reset_value,
+			(void __iomem *) (KSEG1 | svip_board_reset_reg_addr));
+}
+
+static void machine_restart_default(char *command)
+{
+	/* if no device tree found */
+	printk(KERN_WARNING "SVIP: default restart not good for eth switch\n");
+	ltq_w32(0, (void *)(KSEG1 | L2_SPRAM_BASE));
+	ltq_sys1_w32(0x00043F3E, SYS1_RREQR);/* reset all except PER, SUBSYS and CPU0 */
+	ltq_sys1_w32(0x00000100, SYS1_RRLSR);/* release WDT0 reset */
+	ltq_sys1_w32(~0x0c000040, SYS1_CLKCLR);/* restore reset value for clock enables */
+	ltq_sys1_w32(0x00030001, SYS1_RBTR);/* reset SUBSYS (incl. DDR2) and CPU0 */
+	unreachable();
+}
+
+static void machine_halt(void)
+{
+	printk(KERN_NOTICE "System halted.\n");
+	local_irq_disable();
+	unreachable();
+}
+
+static void machine_power_off(void)
+{
+	printk(KERN_NOTICE "Please turn off the power now.\n");
+	local_irq_disable();
+	unreachable();
+}
+
+static int reset_property_exists(void)
+{
+	const u32 *property;
+	int len;
+	struct device_node *dt_reset =
+		of_find_compatible_node(NULL, NULL, "lantiq,svip-reset");
+	if (dt_reset) {
+		property = of_get_property(dt_reset, "svip-toggle-reset-pin", &len);
+		if (property && len == (2 * sizeof(u32))) {
+			svip_board_reset_reg_addr = (unsigned long) be32_to_cpup(property);
+			svip_board_reset_value = (unsigned long) be32_to_cpup(property + 1);
+			return 1;
+		}
+	}
+	printk(KERN_WARNING "SVIP: default restart not good for eth switch\n");
+	return 0;
+}
+
+static int __init mips_reboot_setup(void)
+{
+	if (reset_property_exists())
+		_machine_restart = machine_restart_toggle_pin;
+	else
+		_machine_restart = machine_restart_default;
+	_machine_halt = machine_halt;
+	pm_power_off = machine_power_off;
+	return 0;
+}
+
+arch_initcall(mips_reboot_setup);
--- /dev/null
+++ b/arch/mips/lantiq/svip/sysctrl.c
@@ -0,0 +1,294 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (C) 2011 Thomas Langer <thomas.langer@lantiq.com> */
+/* Copyright (C) 2011 John Crispin <blogic@openwrt.org> */
+/* Copyright (C) 2018 Intel Corporation */
+
+#include <linux/ioport.h>
+#include <linux/export.h>
+#include <linux/clkdev.h>
+#include <linux/of_address.h>
+#include <linux/spinlock.h>
+#include <svip/sysctrl.h>
+#include <asm/delay.h>
+
+#include <lantiq_soc.h>
+#include <svip/sys2_reg.h>
+#include <svip/ebu_reg.h>
+
+#include "../clk.h"
+
+#define sysctl_w32(m, val, reg)	ltq_w32((val), sysctl_membase[m] + (reg))
+#define sysctl_r32(m, val)	ltq_r32(sysctl_membase[m] + (val))
+#define sysctl_w32_mask(m, clear, set, reg) \
+	sysctl_w32(m, (sysctl_r32(m, reg) & ~(clear)) | (set), reg)
+
+#define status_w32(val, reg)	sysctl_w32(SYSCTL_STATUS, val, reg)
+#define status_r32(reg)		sysctl_r32(SYSCTL_STATUS, reg)
+#define status_w32_mask(clear, set, reg) \
+	sysctl_w32_mask(SYSCTL_STATUS, clear, set, reg)
+
+
+static const char *sysctrl_compatible[] = {
+	"lantiq,sys0-svip",
+	"lantiq,sys1-svip",
+	"lantiq,sys2-svip",
+	"lantiq,status-svip",
+	"lantiq,ebu-svip"
+};
+
+void __iomem *sysctl_membase[ARRAY_SIZE(sysctrl_compatible)];
+void __iomem *ltq_sys0_membase, *ltq_sys1_membase, *ltq_ebu_membase;
+EXPORT_SYMBOL_GPL(ltq_sys0_membase);
+EXPORT_SYMBOL_GPL(ltq_sys1_membase);
+EXPORT_SYMBOL_GPL(ltq_ebu_membase);
+
+static inline void sysctl_wait(struct clk *clk,
+	unsigned int test, unsigned int reg)
+{
+	int err = 1000000;
+
+	do {} while (--err && ((sysctl_r32(clk->module, reg)
+		& clk->bits) != test));
+	if (!err)
+		pr_err("module de/activation failed %d %08X %08X %08X\n",
+			clk->module, clk->bits, test,
+			sysctl_r32(clk->module, reg) & clk->bits);
+}
+
+static int sysctl_activate(struct clk *clk)
+{
+	if (clk->module == SYSCTL_SYS1 || clk->module == SYSCTL_SYS2) {
+		sysctl_w32(clk->module, clk->bits, SYS1_CLKENR);
+		sysctl_wait(clk, clk->bits, SYS1_CLKSR);
+	}
+	else
+		pr_err("sysctl_activate: only SYSCTL_SYS1 and SYSCTL_SYS2 are supported");
+	return 0;
+}
+
+static void sysctl_deactivate(struct clk *clk)
+{
+	if (clk->module == SYSCTL_SYS1 || clk->module == SYSCTL_SYS2) {
+		sysctl_w32(clk->module, clk->bits, SYS1_CLKCLR);
+		sysctl_wait(clk, 0, SYS1_CLKSR);
+	}
+	else
+		pr_err("sysctl_deactivate: only SYSCTL_SYS1 and SYSCTL_SYS2 are supported");
+}
+
+static int sysctl_clken(struct clk *clk)
+{
+	if (clk->module == SYSCTL_SYS1 || clk->module == SYSCTL_SYS2) {
+		sysctl_w32(clk->module, clk->bits, SYS1_CLKENR);
+		sysctl_wait(clk, clk->bits, SYS1_CLKSR);
+	}
+	else
+		pr_err("sysctl_clken: only SYSCTL_SYS1 and SYSCTL_SYS2 are supported");
+	return 0;
+}
+
+static void sysctl_clkdis(struct clk *clk)
+{
+	if (clk->module == SYSCTL_SYS1 || clk->module == SYSCTL_SYS2) {
+		sysctl_w32(clk->module, clk->bits, SYS1_CLKCLR);
+		sysctl_wait(clk, 0, SYS1_CLKSR);
+	}
+	else
+		pr_err("sysctl_clkdis: only SYSCTL_SYS1 and SYSCTL_SYS2 are supported");
+}
+
+static void sysctl_reboot(struct clk *clk)
+{
+/*
+	unsigned int act;
+	unsigned int bits;
+
+	act = sysctl_r32(clk->module, SYSCTL_ACT);
+	bits = ~act & clk->bits;
+	if (bits != 0) {
+		sysctl_w32(clk->module, bits, SYSCTL_CLKEN);
+		sysctl_w32(clk->module, bits, SYSCTL_ACT);
+		sysctl_wait(clk, bits, SYSCTL_ACTS);
+	}
+	sysctl_w32(clk->module, act & clk->bits, SYSCTL_RBT);
+	sysctl_wait(clk, clk->bits, SYSCTL_ACTS);
+*/
+}
+
+static inline void clkdev_add_sys(const char *dev, unsigned int module,
+	unsigned int bits)
+{
+	struct clk *clk = kzalloc(sizeof(struct clk), GFP_KERNEL);
+
+	clk->cl.dev_id = dev;
+	clk->cl.con_id = NULL;
+	clk->cl.clk = clk;
+	clk->module = module;
+	clk->bits = bits;
+	clk->activate = sysctl_activate;
+	clk->deactivate = sysctl_deactivate;
+	clk->enable = sysctl_clken;
+	clk->disable = sysctl_clkdis;
+	clk->reboot = sysctl_reboot;
+	clkdev_add(&clk->cl);
+}
+
+static unsigned int svip_cpu_hz(void)
+{
+	/* Magic BootROM speed location... */
+	if ((*(u32 *)0x9fc07ff0) == 1)
+		return *(u32 *)0x9fc07ff4;
+
+	if (STATUS_CONFIG_CLK_MODE_GET(status_r32(STATUS_CONFIG)) == 1) {
+		/* xT16 Switch-IP clock mode */
+		return 393216000;
+	} else {
+		switch (SYS0_PLL1CR_PLLDIV_GET(sysctl_r32(SYSCTL_SYS0,SYS0_PLL1CR))) {
+		case 3:
+			return 475000000;
+		case 2:
+			return 450000000;
+		case 1:
+			return 425000000;
+		default:
+			return 400000000;
+		}
+	}
+}
+
+static unsigned int svip_fpi_hz(void)
+{
+	u32 fbs0_div[2] = {4, 8};
+	u32 div;
+
+	div = SYS1_FPICR_FPIDIV_GET(sysctl_r32(SYSCTL_SYS1,SYS1_FPICR));
+	return svip_cpu_hz()/fbs0_div[div];
+}
+
+static unsigned int svip_io_region_clock(void)
+{
+	return 200000000; /* 200 MHz */
+}
+
+
+void __iomem * __init sysctrl_init(const char *compatible)
+{
+	struct device_node *np;
+	struct resource res;
+	void __iomem *base;
+
+	np = of_find_compatible_node(NULL, NULL, compatible);
+	if (!np)
+		panic("Failed to load node '%s'", compatible);
+
+	if (of_address_to_resource(np, 0, &res))
+		panic("Failed to get '%s' resources", compatible);
+
+	if (request_mem_region(res.start, resource_size(&res), res.name) < 0)
+		pr_err("Failed to request '%s' mem-region\n", compatible);
+
+	base = ioremap_nocache(res.start, resource_size(&res));
+	if (!base)
+		panic("Failed to remap '%s' resources", compatible);
+
+	return base;
+}
+
+
+void __init ltq_soc_init(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(sysctrl_compatible); i++)
+		sysctl_membase[i] = sysctrl_init(sysctrl_compatible[i]);
+
+	ltq_sys0_membase = sysctl_membase[SYSCTL_SYS0];
+	ltq_sys1_membase = sysctl_membase[SYSCTL_SYS1];
+	ltq_ebu_membase = sysctl_membase[SYSCTL_EBU];
+
+	clkdev_add_static(svip_cpu_hz(), svip_fpi_hz(),
+		svip_io_region_clock(), 0);
+
+	/* add our clock domains */
+	clkdev_add_sys("14100100.serial0", SYSCTL_SYS1, SYS1_CLKENR_ASC0);
+	clkdev_add_sys("14100200.serial1", SYSCTL_SYS1, SYS1_CLKENR_ASC1);
+	clkdev_add_sys("14100300.spi", SYSCTL_SYS1, SYS1_CLKENR_SSC0);
+	clkdev_add_sys("14100400.spi", SYSCTL_SYS1, SYS1_CLKENR_SSC1);
+	clkdev_add_sys("14108000.spi", SYSCTL_SYS1, SYS1_CLKENR_SSC2);
+	clkdev_add_sys("14100600.port", SYSCTL_SYS1, SYS1_CLKENR_PORT0);
+	clkdev_add_sys("14108100.port", SYSCTL_SYS1, SYS1_CLKENR_PORT1);
+	clkdev_add_sys("14100800.port", SYSCTL_SYS1, SYS1_CLKENR_PORT2);
+	clkdev_add_sys("14100900.port", SYSCTL_SYS1, SYS1_CLKENR_PORT3);
+	clkdev_add_sys("14104000.dma", SYSCTL_SYS1, SYS1_CLKENR_DMA);
+	clkdev_add_sys("18000000.eth", SYSCTL_SYS1, SYS1_CLKENR_ETHSW);
+	clkdev_add_sys("1e000400.port", SYSCTL_SYS2, SYS2_CLKENR_PORT4);
+
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_HWSYNC);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_MBS);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_SWINT);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_HWACC3);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_HWACC2);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_HWACC1);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_HWACC0);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_SIF7);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_SIF6);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_SIF5);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_SIF4);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_SIF3);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_SIF2);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_SIF1);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_SIF0);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_DFEV7);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_DFEV6);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_DFEV5);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_DFEV4);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_DFEV3);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_DFEV2);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_DFEV1);
+	ltq_sysctl_clken(SYSCTL_SYS2, SYS2_CLKENR_DFEV0);
+
+	/* EBU configuration */
+	ebu_w32(0x120000f1, LTQ_EBU_ADDR_SEL_2);
+#ifdef CONFIG_CPU_LITTLE_ENDIAN
+	ebu_w32(LTQ_EBU_CON_0_SETUP |
+		LTQ_EBU_CON_0_BCGEN_VAL(0x02) |
+		LTQ_EBU_CON_0_WAITWRC_VAL(7) |
+		LTQ_EBU_CON_0_WAITRDC_VAL(3) |
+		LTQ_EBU_CON_0_HOLDC_VAL(3) |
+		LTQ_EBU_CON_0_RECOVC_VAL(3) |
+		LTQ_EBU_CON_0_CMULT_VAL(3), LTQ_EBU_CON_2);
+#else
+	ebu_w32(LTQ_EBU_CON_0_ADSWP |
+		LTQ_EBU_CON_0_SETUP |
+		LTQ_EBU_CON_0_BCGEN_VAL(0x02) |
+		LTQ_EBU_CON_0_WAITWRC_VAL(7) |
+		LTQ_EBU_CON_0_WAITRDC_VAL(3) |
+		LTQ_EBU_CON_0_HOLDC_VAL(3) |
+		LTQ_EBU_CON_0_RECOVC_VAL(3) |
+		LTQ_EBU_CON_0_CMULT_VAL(3), LTQ_EBU_CON_2);
+#endif
+}
+
+void ltq_sysctl_clken(int module, unsigned int mask)
+{
+	struct clk clk = { .module = module, .bits = mask };
+	sysctl_clken(&clk);
+}
+EXPORT_SYMBOL(ltq_sysctl_clken);
+
+void ltq_sysctl_clkdis(int module, unsigned int mask)
+{
+	struct clk clk = { .module = module, .bits = mask };
+	sysctl_clkdis(&clk);
+}
+EXPORT_SYMBOL(ltq_sysctl_clkdis);
+/*
+ * for compatibility to external drivers from Lantiq
+ * see arch/mips/include/asm/mach-lantiq/svip/sysctrl.h
+ */
+void ltq_sysctl_chipid_get(unsigned int *chipid)
+{
+	if (chipid)
+		*chipid = ltq_r32(SVIP_CHIPID);
+}
+EXPORT_SYMBOL(ltq_sysctl_chipid_get);
