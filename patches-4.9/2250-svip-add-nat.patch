# HG changeset patch
# Parent  39493a48e073bfd91b05f005873752466371af85
Lantiq SVIP SoC NAT implementation

--- /dev/null
+++ b/include/linux/svip_nat.h
@@ -0,0 +1,23 @@
+/******************************************************************************
+
+	Copyright (c) 2014
+	Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+#ifndef _SVIP_NAT_H
+#define _SVIP_NAT_H
+
+/*  The declarations here have to be in a header file, because
+ *  they need to be known both to the kernel module
+ *  (in chardev.c) and the process calling ioctl (ioctl.c)
+ */
+#include <linux/svip_nat_io.h>
+
+#define SVIP_NAT_VERSION "3.4"
+extern int do_SVIP_NAT(struct sk_buff *);
+extern int ipv6_do_SVIP_NAT(struct sk_buff *);
+
+#endif
--- /dev/null
+++ b/include/linux/svip_nat_io.h
@@ -0,0 +1,15 @@
+/******************************************************************************
+
+	Copyright (c) 2014
+	Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+#ifndef _SVIP_NAT_IO_H_
+#define _SVIP_NAT_IO_H_
+
+#include <uapi/linux/svip_nat_io.h>
+
+#endif
--- a/include/uapi/linux/Kbuild
+++ b/include/uapi/linux/Kbuild
@@ -398,6 +398,7 @@ header-y += stat.h
 header-y += stddef.h
 header-y += string.h
 header-y += suspend_ioctls.h
+header-y += svip_nat_io.h
 header-y += swab.h
 header-y += switch.h
 header-y += synclink.h
--- /dev/null
+++ b/include/uapi/linux/svip_nat_io.h
@@ -0,0 +1,157 @@
+/******************************************************************************
+
+	Copyright (c) 2014
+	Lantiq Deutschland GmbH
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+#ifndef _UAPI__SVIP_NAT_IO_H_
+#define _UAPI__SVIP_NAT_IO_H_
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+#define SVIP_NAT_DEVICE_NAME        "svip_nat"
+#define PATH_SVIP_NAT_DEVICE_NAME   "/dev/"SVIP_NAT_DEVICE_NAME
+
+#define MAJOR_NUM_SVIP_NAT          10
+#define MINOR_NUM_SVIP_NAT          120
+
+/** @defgroup SVIP_NATAPI  SVIP Custom NAT ioctl interface.
+  An ioctl interface is provided to add a rule into the SVIP NAT table and
+  to respectively remove the rule form it. The ioctl interface is accessible
+  using the fd issued upon opening the special device node /dev/svip_nat.
+  @{  */
+
+/** Used to add a new rule to the SVIP Custom NAT table. If a rule already
+  exists for the target UDP port, that rule shall be overwritten.
+
+  \param SVIP_NAT_IO_Rule_t* The parameter points to a
+  \ref SVIP_NAT_IO_Rule_t structure.
+  */
+#define FIO_SVIP_NAT_RULE_ADD \
+	_IOW(MAJOR_NUM_SVIP_NAT, 1, SVIP_NAT_IO_Rule_t)
+
+/** Used to remove a rule from the SVIP Custom NAT table. No check is
+  performed whether the rule already exists or not. The remove operation is
+  performed as long as the target UDP port is within the defined port range.
+
+  \param SVIP_NAT_IO_Rule_t* The parameter points to a
+  \ref SVIP_NAT_IO_Rule_t structure.
+  */
+#define FIO_SVIP_NAT_RULE_REMOVE \
+	_IOW(MAJOR_NUM_SVIP_NAT, 2, SVIP_NAT_IO_Rule_t)
+
+/** Used to list all rules in the SVIP Custom NAT table.
+
+  \param <none>
+  */
+#define FIO_SVIP_NAT_RULE_LIST \
+	_IO(MAJOR_NUM_SVIP_NAT, 3)
+
+#ifdef CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK
+/** Used to add a valid IP for NAT. NAT is performed only on packets whose
+ * destination IPs have been added with this IO control.
+
+  \param SVIP_IP_ADDR_t* The parameter points to a
+  \ref SVIP_NAT_DESTIP_t structure.
+  */
+#define FIO_SVIP_NAT_DESTIP_CHECK_ADD \
+	_IOW(MAJOR_NUM_SVIP_NAT, 4, SVIP_NAT_DESTIP_t)
+
+/** Used to remove a valid IP for NAT.
+
+  \param SVIP_IP_ADDR_t* The parameter points to a
+  \ref SVIP_NAT_DESTIP_t structure.
+  */
+#define FIO_SVIP_NAT_DESTIP_CHECK_REMOVE \
+	_IOW(MAJOR_NUM_SVIP_NAT, 5, SVIP_NAT_DESTIP_t)
+
+/** Used to list all IPs valid for NAT.
+
+  \param <none>
+  */
+#define FIO_SVIP_NAT_DESTIP_LIST_GET \
+	_IO(MAJOR_NUM_SVIP_NAT, 6)
+#endif /* CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK */
+
+/** Used to write the base UDP port number of SVIP Custom NAT.
+
+  \param SVIP_UDP_PORT_t* The parameter points to a
+  \ref SVIP_UDP_PORT_t structure.
+  */
+#define FIO_SVIP_NAT_UDP_PORT_BASE_SET \
+	_IOW(MAJOR_NUM_SVIP_NAT, 7, SVIP_UDP_PORT_t)
+
+/** Used to read the base UDP port number of SVIP Custom NAT.
+
+  \param SVIP_UDP_PORT_t* The parameter points to a
+  \ref SVIP_UDP_PORT_t structure.
+  */
+#define FIO_SVIP_NAT_UDP_PORT_BASE_GET \
+	_IOWR(MAJOR_NUM_SVIP_NAT, 8, SVIP_UDP_PORT_t)
+
+#ifndef ETH_ALEN
+#define ETH_ALEN         6 /* Octets in one ethernet address */
+#endif
+
+/** Type to identify IPv4 and IPv6 addresses */
+typedef enum {
+	SVIP_IPV4_ADDR_TYPE,
+	SVIP_IPV6_ADDR_TYPE
+} SVIP_IP_ADDR_TYPE_t;
+
+typedef __u32 SVIP_IPV4_ADDR_t;
+
+/** IPv6 address type, style taken over from Linux */
+typedef struct SVIP_IPV6_ADDR {
+	union {
+		__u8 addr8[16];
+		__u16 addr16[8];
+		__u32 addr32[4];
+	} ipv6_u;
+#define ipv6_addr8 ipv6_u.addr8
+#define ipv6_addr16 ipv6_u.addr16
+#define ipv6_addr32 ipv6_u.addr32
+} SVIP_IPV6_ADDR_t;
+
+/** union of IPv4 and IPv6 addresses */
+typedef union {
+	SVIP_IPV4_ADDR_t v4;
+	SVIP_IPV6_ADDR_t v6;
+} SVIP_IP_ADDR_UNION_t;
+
+/** UDP port in network-byte order */
+typedef __u16 SVIP_UDP_PORT_t;
+
+/** NAT parameters part of the NAT table.
+  These parameters are configurable through the NAT API. */
+typedef struct SVIP_NAT_IO_Rule {
+	/** IP address type */
+	SVIP_IP_ADDR_TYPE_t typeIP;
+	/** Remote peer IP address */
+	SVIP_IP_ADDR_UNION_t remIP;
+	/** Remote peer, MAC address */
+	__u8 remMAC[ETH_ALEN];
+	/** Target SVIP, IP address (local peer) */
+	SVIP_IP_ADDR_UNION_t locIP;
+	/** Target SVIP, MAC address */
+	__u8 locMAC[ETH_ALEN];
+	/** Target SVIP, UDP port number */
+	SVIP_UDP_PORT_t locUDP;
+} SVIP_NAT_IO_Rule_t;
+
+#ifdef CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK
+/** SVIP NAT IP filter structure */
+typedef struct SVIP_NAT_DESTIP {
+	/** address type */
+	SVIP_IP_ADDR_TYPE_t typeIP;
+	/** IP address */
+	SVIP_IP_ADDR_UNION_t IP;
+} SVIP_NAT_DESTIP_t;
+#endif /* CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK */
+
+/** @} */
+#endif
--- a/net/Kconfig
+++ b/net/Kconfig
@@ -95,6 +95,71 @@ config LTQ_UDP_REDIRECT
 	  UDP redirection.
 
 if INET
+
+menu "VINETIC-SVIP NAT options"
+
+config LTQ_SVIP_NAT
+	default n
+	bool "VINETIC-SVIP NAT"
+	depends on SOC_SVIP
+	---help---
+	Performs MAC and IP address translation of incoming and ougoing
+	IP packets relative the address mapping details provided by the
+	SVIP NAT rules. The packets will be intercept in the IP module and
+	when an appropriate NAT rule exists the source and destination address
+	details are replaced, and the packets are sent out the destined Ethernet
+	interface.
+	This NAT solution is tailored for Lantiq VINETIC-SVIP VoIP applications.
+
+config LTQ_SVIP_NAT_DESTIP_CHECK
+	bool "SVIP NAT destination IP filter"
+	depends on LTQ_SVIP_NAT
+	default y
+	---help---
+	Enables NAT filtering for LTQ_SVIP_NAT depending on IP address. NAT is
+	performed only on packets whose destination IP addresses have been added to
+	the allowed address list. Addition to and removal from the list is done
+	using svip_nat application.
+
+config LTQ_SVIP_NAT_DESTIP_LIST_SIZE
+	int "SVIP NAT destination IP filter list length"
+	depends on LTQ_SVIP_NAT_DESTIP_CHECK
+	default 10
+	---help---
+	Length of SVIP NAT destination IP filter list. Specifies the number of IP
+	addresses that can be stored in the allowed address list.
+
+config LTQ_SVIP_NAT_RULES_TOTAL
+	int "SVIP NAT table total rules"
+	depends on LTQ_SVIP_NAT
+	default 192
+	---help---
+	Defines the size of the VINETIC-SVIP NAT table i.e. the total number of NAT
+	rules. In order to select a correct size for the table, one has to consider
+	the number of VINETIC-SVIP devices available on the system and the total
+	number of analog channels available on the devices.
+	For example: for a system consisting of one VINETIC-SVIP16 device and one
+	VINETIC-SVIP8, one would need (16+8)*3=72 rules.
+	Explanation: for each analog channel there are twice as many coder channels
+	available where for each coder one rule applies. That is, for a VINETIC-SVIP16,
+	a device with 16 analog channels one needs 16*2=32 rules.
+	Additionally, one needs to allocate a rule per analog channel if one uses
+	T.38 and for these streams one assigns a unique UDP port. That is how we
+	come to a total number equaling 3 times the number of analog channels.
+
+config LTQ_SVIP_NAT_UDP_PORT_BASE
+	int "SVIP NAT UDP port base number"
+	depends on LTQ_SVIP_NAT
+	default 50000
+	---help---
+	Defines the base UDP port number to be used in the rules.
+	The VINETIC-SVIP NAT table is a simple array of rules. The rules are simply
+	indexed relative the locUDP number. E.g. rule which locUDP port equals the base
+	UDP port is stored at index zero, the rule which locUDP port equals the base
+	UDP port number plus one is stored at index 1, etc.
+
+endmenu
+
 source "net/ipv4/Kconfig"
 source "net/ipv6/Kconfig"
 source "net/netlabel/Kconfig"
--- a/net/ipv4/Makefile
+++ b/net/ipv4/Makefile
@@ -64,3 +64,4 @@ obj-$(CONFIG_NETLABEL) += cipso_ipv4.o
 
 obj-$(CONFIG_XFRM) += xfrm4_policy.o xfrm4_state.o xfrm4_input.o \
 		      xfrm4_output.o xfrm4_protocol.o
+obj-$(CONFIG_LTQ_SVIP_NAT) += svip_nat.o
--- a/net/ipv4/ip_input.c
+++ b/net/ipv4/ip_input.c
@@ -147,6 +147,9 @@
 #include <linux/mroute.h>
 #include <linux/netlink.h>
 #include <net/dst_metadata.h>
+#ifdef CONFIG_LTQ_SVIP_NAT
+#include <linux/svip_nat.h>
+#endif
 
 /*
  *	Process Router Attention IP option (RFC 2113)
@@ -485,6 +488,13 @@ int ip_rcv(struct sk_buff *skb, struct n
 	/* Must drop socket now because of tproxy. */
 	skb_orphan(skb);
 
+#ifdef CONFIG_LTQ_SVIP_NAT
+	if (do_SVIP_NAT(skb)) {
+	/* SVIP NAT performed, receiving successful */
+	return NET_RX_SUCCESS;
+	}
+#endif
+
 	return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,
 		       net, NULL, skb, dev, NULL,
 		       ip_rcv_finish);
--- /dev/null
+++ b/net/ipv4/svip_nat.c
@@ -0,0 +1,2561 @@
+/******************************************************************************
+**
+** FILE NAME	: svip_nat.c
+** PROJECT	: Lantiq voice co
+** MODULES	: Lantiq VINETIC-SVIP NAT
+** DATE		: 13 August 2014
+** AUTHOR	: Martins Pukitis
+** DESCRIPTION	: Lantiq VINETIC-SVIP NAT implementation
+** COPYRIGHT	: Copyright (c) 2014
+**		  Lantiq Deutschland
+**
+**	This program is free software; you can redistribute it and/or modify
+**	it under the terms of the GNU General Public License as published by
+**	the Free Software Foundation; either version 2 of the License, or
+**	(at your option) any later version.
+**
+**	Adapted from VINETIC-SVIP NAT written by Risto Minev
+**
+** HISTORY
+** $Date                $Author            $Comment
+** 13 Aug 2014          Martins Pukitis    Initial version
+*******************************************************************************/
+
+#include <linux/module.h>
+#include <linux/netfilter_ipv4.h>
+#include <linux/if_ether.h>
+#include <linux/netdevice.h>
+#include <linux/inetdevice.h>
+#include <linux/in.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <net/ipv6.h>
+#include <net/addrconf.h>
+#include <linux/if_vlan.h>
+#include <linux/udp.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/in6.h>
+#include <linux/miscdevice.h>
+#include <asm/checksum.h>
+#include "../8021q/vlan.h"
+
+#include <linux/svip_nat.h>
+
+MODULE_AUTHOR("Lantiq Deutschland GmbH");
+MODULE_DESCRIPTION("SVIP Network Address Translation module");
+MODULE_LICENSE("GPL");
+
+#define SVIP_NAT_INFO_STR "@(#)SVIP NAT, version "SVIP_NAT_VERSION
+
+#define SVIP_UDP_FROM  (nat_udp_port_base)
+#define SVIP_UDP_TO    ((nat_udp_port_base)+(CONFIG_LTQ_SVIP_NAT_RULES_TOTAL)-1)
+
+#define SVIP_PORT_INRANGE(port) \
+	((port) >= (SVIP_UDP_FROM) && (port) <= (SVIP_UDP_TO))
+
+#define SVIP_PORT_INDEX(port)   (port - SVIP_UDP_FROM)
+
+#ifdef CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK
+#define SVIP_NAT_DESTIP_LIST_SIZE   (CONFIG_LTQ_SVIP_NAT_DESTIP_LIST_SIZE)
+#endif
+
+#define SVIP_NET_DEV_ETH0_IDX       0
+#define SVIP_NET_DEV_ETH1_IDX       1
+#define SVIP_NET_DEV_VETH0_IDX      2
+#define SVIP_NET_DEV_LO_IDX         3
+
+#define SVIP_NET_DEV_ETH0_NAME      "eth0"
+#define SVIP_NET_DEV_ETH1_NAME      "eth1"
+#define SVIP_NET_DEV_VETH0_NAME     "veth0"
+#define SVIP_NET_DEV_LO_NAME        "lo"
+
+#define SVIP_NAT_STATS_LOC2REM      0
+#define SVIP_NAT_STATS_REM2LOC      1
+#define SVIP_NAT_STATS_TYPES        2
+
+#if !(defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE))
+#define VLAN_8021Q_UNUSED
+#endif
+
+struct SVIP_NAT_stats {
+	unsigned long in_packets;
+	unsigned long out_packets;
+	unsigned long out_errors;
+};
+
+struct SVIP_NAT_table_entry {
+	SVIP_NAT_IO_Rule_t nat_rule;
+	struct SVIP_NAT_stats nat_stats[SVIP_NAT_STATS_TYPES];
+};
+
+/* pointer to the SVIP NAT table */
+static struct SVIP_NAT_table_entry *nat_table;
+#ifdef CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK
+/* IP address arrays */
+static SVIP_IPV4_ADDR_t nat_dest_IPv4[CONFIG_LTQ_SVIP_NAT_DESTIP_LIST_SIZE];
+static int nat_dest_IPv4_size;
+static SVIP_IPV6_ADDR_t nat_dest_IPv6[CONFIG_LTQ_SVIP_NAT_DESTIP_LIST_SIZE];
+static int nat_dest_IPv6_size;
+#endif
+/* base UDP port number */
+static SVIP_UDP_PORT_t nat_udp_port_base = CONFIG_LTQ_SVIP_NAT_UDP_PORT_BASE;
+
+struct net_device *net_devs[3];
+static u32 *paddr_eth0;
+static u32 *paddr_eth1;
+static u32 *pmask_eth1;
+static u32 *paddr_veth0;
+static u32 *pmask_veth0;
+
+struct in6_addr *paddr_eth0_ip6 = NULL, *paddr_eth1_ip6 = NULL,
+	*paddr_veth0_ip6 = NULL;
+static u32 prefix_len_eth0;
+static u32 prefix_len_veth0;
+
+static struct semaphore *sem_nat_tbl_access;
+
+static int device_open;
+
+static long SVIP_NAT_device_ioctl(struct file *file, unsigned int ioctl_num,
+	unsigned long ioctl_param);
+static int SVIP_NAT_device_release(struct inode *, struct file *);
+static int SVIP_NAT_device_open(struct inode *, struct file *);
+
+/* This structure holds the interface functions supported by
+ * the SVIP NAT configuration device.
+ */
+const struct file_operations SVIP_NAT_fops = {
+	.owner = THIS_MODULE, .llseek = NULL, /* seek */
+	.read = NULL, .write = NULL,
+	.poll = NULL, /* select */
+	.unlocked_ioctl = SVIP_NAT_device_ioctl, .mmap = NULL, /* mmap */
+	.open = SVIP_NAT_device_open, /* open, */
+	.flush = NULL, /* flush */
+	.release = SVIP_NAT_device_release /* close */
+};
+
+/** Structure holding MISC module operations */
+static struct miscdevice SVIP_NAT_miscdev = {
+	.minor = MINOR_NUM_SVIP_NAT,
+	.name = SVIP_NAT_DEVICE_NAME,
+	.fops = &SVIP_NAT_fops
+};
+
+#ifdef CONFIG_SVIP_FW_PKT_SNIFFER
+int SVIP_NAT_sniffer;
+unsigned char SVIP_NAT_sniffer_MAC[ETH_ALEN];
+int SVIP_NAT_sniffer_MAC_set;
+#endif
+
+/* single call read proc entry callback function */
+typedef void (*proc_single_callback_t)(struct seq_file *);
+/* multiple call read proc entry callback function */
+typedef int (*proc_callback_t)(struct seq_file *, int);
+/* write function */
+typedef ssize_t (*proc_write_t)(struct file *file, const char __user *buffer,
+	size_t count, loff_t *data);
+
+static void *SVIP_NAT_seq_start(struct seq_file *s, loff_t *pos);
+static void *SVIP_NAT_seq_next(struct seq_file *s, void *v, loff_t *pos);
+static void SVIP_NAT_seq_stop(struct seq_file *s, void *v);
+static int SVIP_NAT_seq_show(struct seq_file *s, void *v);
+
+struct proc_file_entry {
+	/* function used for data output */
+	proc_callback_t callback;
+	/* current output position */
+	int pos;
+	/* maximum output position */
+	int max_pos;
+};
+
+struct proc_entry {
+	char *name;
+	proc_single_callback_t single_callback;
+	proc_callback_t callback;
+	int max_pos;
+	proc_write_t write_function;
+	struct file_operations ops;
+};
+
+static const struct seq_operations SVIP_NAT_seq_ops = {
+	.start = SVIP_NAT_seq_start,
+	.next = SVIP_NAT_seq_next,
+	.stop = SVIP_NAT_seq_stop,
+	.show = SVIP_NAT_seq_show
+};
+
+static int SVIP_NAT_proc_read_NAT(struct seq_file *s, int pos);
+static int SVIP_NAT_read_NAT(char *buf, int count, int pos);
+#ifdef CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK
+static int SVIP_NAT_proc_read_dest_IP(struct seq_file *s, int pos);
+static int SVIP_NAT_read_dest_IP(char *buf, int count, int pos);
+#endif
+static void SVIP_NAT_proc_read_port_base(struct seq_file *s);
+#ifdef CONFIG_SVIP_FW_PKT_SNIFFER
+static void SVIP_NAT_proc_read_sniffer_MAC(struct seq_file *s);
+static ssize_t SVIP_NAT_proc_write_sniffer_MAC(struct file *file,
+	const char __user *buffer,
+	size_t count, loff_t *data);
+static void SVIP_NAT_proc_read_sniffer_on_off(struct seq_file *s);
+static ssize_t SVIP_NAT_proc_write_sniffer_on_off(struct file *file,
+	const char __user *buffer, size_t count, loff_t *data);
+#endif
+
+static struct proc_entry proc_entries[] = {
+	{ "nat", NULL, SVIP_NAT_proc_read_NAT,
+		CONFIG_LTQ_SVIP_NAT_RULES_TOTAL - 1, NULL },
+#ifdef CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK
+	{ "destip", NULL, SVIP_NAT_proc_read_dest_IP,
+		(SVIP_NAT_DESTIP_LIST_SIZE << 1) - 1, NULL },
+#endif
+#ifdef CONFIG_SVIP_FW_PKT_SNIFFER
+	{"snifferMAC", SVIP_NAT_proc_read_sniffer_MAC, NULL, 0,
+		SVIP_NAT_proc_write_sniffer_MAC},
+	{"snifferOnOff", SVIP_NAT_proc_read_sniffer_on_off, NULL, 0,
+		SVIP_NAT_proc_write_sniffer_on_off},
+#endif
+	{ "portbase", SVIP_NAT_proc_read_port_base, NULL, 0, NULL }
+};
+
+/**
+
+ Read NAT table from the driver.
+
+ \param s
+ \param pos  NAT entry to print
+
+ \return
+ zero or an error code
+ */
+static int SVIP_NAT_proc_read_NAT(struct seq_file *s, int pos)
+{
+	return SVIP_NAT_read_NAT((char *) s, 0, pos);
+}
+
+/******************************************************************************/
+/**
+ Function for reading /proc/net/svip_nat/nat
+
+ \arguments
+ buf   - pointer to read buffer or seq_file structure
+ count - size of read buffer. If size is 0 then buf is pointer to seq_file
+ structure
+ pos   - NAT entry to print
+
+ \return
+ if buf is pointer to buffer, length of read data into buffer, else 0 or error
+ code
+
+*******************************************************************************/
+static int SVIP_NAT_read_NAT(char *buf, int count, int pos)
+{
+	int j;
+	int slen;
+	SVIP_NAT_IO_Rule_t *nat_rule;
+
+	if (count == 0) {
+		/* write to seq_file */
+		struct seq_file *s = (struct seq_file *) buf;
+		char tmp[40];
+
+		if (pos == 0) {
+			seq_puts(s, "rem MAC            " /* 19 char */
+				"rem IP                                   "
+				/* 41 char */
+				"loc MAC            " /* 19 char */
+				"loc IP                                   "
+				/* 41 char */
+				"loc UDP  " /* 9 char */
+				"loc->rem(in/out/err)  " /* 22 char */
+				"rem->loc(in/out/err)\n\r"); /* 22 char  */
+			/* 173 total */
+
+			seq_puts(s, "-----------------  " /* 19 char */
+				"---------------------------------------  "
+				/* 41 char */
+				"-----------------  " /* 19 char */
+				"---------------------------------------  "
+				/* 41 char */
+				"-------  " /* 9 char */
+				"--------------------  " /* 22 char */
+				"--------------------\n\r");
+		}
+
+		nat_rule = &nat_table[pos].nat_rule;
+
+		if (nat_rule->locUDP == 0)
+			return 0;
+
+		/* remMAC */
+		slen = 0;
+		for (j = 0; j < ETH_ALEN; j++) {
+			slen += sprintf(tmp + slen, "%02x%s",
+				nat_rule->remMAC[j],
+				j < ETH_ALEN - 1 ? ":" : " ");
+		}
+		seq_printf(s, "%s", tmp);
+		for (j = 0; j < (19 - slen); j++)
+			seq_puts(s, " ");
+
+		/* remIP */
+		if (nat_rule->typeIP == SVIP_IPV4_ADDR_TYPE) {
+			slen = sprintf(tmp, "%d.%d.%d.%d",
+				(ntohl(nat_rule->remIP.v4) >> 24) & 0xff,
+				(ntohl(nat_rule->remIP.v4) >> 16) & 0xff,
+				(ntohl(nat_rule->remIP.v4) >> 8) & 0xff,
+				(ntohl(nat_rule->remIP.v4) >> 0) & 0xff);
+		} else {
+			slen = sprintf(tmp,
+				"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x",
+				ntohs(nat_rule->remIP.v6.ipv6_addr16[0]),
+				ntohs(nat_rule->remIP.v6.ipv6_addr16[1]),
+				ntohs(nat_rule->remIP.v6.ipv6_addr16[2]),
+				ntohs(nat_rule->remIP.v6.ipv6_addr16[3]),
+				ntohs(nat_rule->remIP.v6.ipv6_addr16[4]),
+				ntohs(nat_rule->remIP.v6.ipv6_addr16[5]),
+				ntohs(nat_rule->remIP.v6.ipv6_addr16[6]),
+				ntohs(nat_rule->remIP.v6.ipv6_addr16[7]));
+		}
+		seq_printf(s, "%s", tmp);
+		for (j = 0; j < (41 - slen); j++)
+			seq_puts(s, " ");
+
+		/* locMAC */
+		slen = 0;
+		for (j = 0; j < ETH_ALEN; j++) {
+			slen += sprintf(tmp + slen, "%02x%s",
+				nat_rule->locMAC[j],
+				j < ETH_ALEN - 1 ? ":" : " ");
+		}
+		seq_printf(s, "%s", tmp);
+		for (j = 0; j < (19 - slen); j++)
+			seq_puts(s, " ");
+
+		/* locIP */
+		if (nat_rule->typeIP == SVIP_IPV4_ADDR_TYPE) {
+			slen = sprintf(tmp, "%d.%d.%d.%d",
+				(ntohl(nat_rule->locIP.v4) >> 24) & 0xff,
+				(ntohl(nat_rule->locIP.v4) >> 16) & 0xff,
+				(ntohl(nat_rule->locIP.v4) >> 8) & 0xff,
+				(ntohl(nat_rule->locIP.v4) >> 0) & 0xff);
+		} else {
+			slen = sprintf(tmp,
+				"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x",
+				ntohs(nat_rule->locIP.v6.ipv6_addr16[0]),
+				ntohs(nat_rule->locIP.v6.ipv6_addr16[1]),
+				ntohs(nat_rule->locIP.v6.ipv6_addr16[2]),
+				ntohs(nat_rule->locIP.v6.ipv6_addr16[3]),
+				ntohs(nat_rule->locIP.v6.ipv6_addr16[4]),
+				ntohs(nat_rule->locIP.v6.ipv6_addr16[5]),
+				ntohs(nat_rule->locIP.v6.ipv6_addr16[6]),
+				ntohs(nat_rule->locIP.v6.ipv6_addr16[7]));
+		}
+		seq_printf(s, "%s", tmp);
+		for (j = 0; j < (41 - slen); j++)
+			seq_puts(s, " ");
+
+		/* locUDP */
+		slen = sprintf(tmp, "%d", ntohs(nat_rule->locUDP));
+		seq_printf(s, "%s", tmp);
+		for (j = 0; j < (9 - slen); j++)
+			seq_puts(s, " ");
+
+		/* NAT statistics, Local to Remote translation */
+		slen = sprintf(tmp, "(%ld/%ld/%ld)",
+			nat_table[pos].nat_stats[SVIP_NAT_STATS_LOC2REM].
+			in_packets,
+			nat_table[pos].nat_stats[SVIP_NAT_STATS_LOC2REM].
+			out_packets,
+			nat_table[pos].nat_stats[SVIP_NAT_STATS_LOC2REM].
+			out_errors);
+		seq_printf(s, "%s", tmp);
+		for (j = 0; j < (22 - slen); j++)
+			seq_puts(s, " ");
+
+		/* NAT statistics, Remote to Local translation */
+		seq_printf(s, "(%ld/%ld/%ld)\n\r",
+			nat_table[pos].nat_stats[SVIP_NAT_STATS_REM2LOC].
+			in_packets,
+			nat_table[pos].nat_stats[SVIP_NAT_STATS_REM2LOC].
+			out_packets,
+			nat_table[pos].nat_stats[SVIP_NAT_STATS_REM2LOC].
+			out_errors);
+	} else {
+		/* write to memory buffer */
+		int len = 0;
+
+		if (pos == 0) {
+			len = sprintf(buf + len,
+				"rem MAC            " /* 19 char */
+				"rem IP                                   "
+				/* 41 char */
+				"loc MAC            " /* 19 char */
+				"loc IP                                   "
+				/* 41 char */
+				"loc UDP  " /* 9 char */
+				"loc->rem(in/out/err)  " /* 22 char */
+				"rem->loc(in/out/err)\n\r"); /* 22 char */
+			/* 173 total */
+
+			len += sprintf(buf + len,
+				"-----------------  " /* 19 char */
+				"---------------------------------------  "
+				/* 41 char */
+				"-----------------  " /* 19 char */
+				"---------------------------------------  "
+				/* 41 char */
+				"-------  " /* 9 char */
+				"--------------------  " /* 22 char */
+				"--------------------\n\r");
+		}
+
+		nat_rule = &nat_table[pos].nat_rule;
+
+		if (nat_rule->locUDP == 0)
+			return len;
+
+		/* make sure not to overwrite the buffer */
+		if (count < len + 173)
+			return len;
+
+		/* remMAC */
+		slen = 0;
+		for (j = 0; j < ETH_ALEN; j++) {
+			slen += sprintf(buf + len + slen, "%02x%s",
+				nat_rule->remMAC[j],
+				j < ETH_ALEN - 1 ? ":" : " ");
+		}
+		len += slen;
+		for (j = 0; j < (19 - slen); j++)
+			len += sprintf(buf + len, " ");
+
+		/* remIP */
+		if (nat_rule->typeIP == SVIP_IPV4_ADDR_TYPE) {
+			slen = sprintf(buf + len, "%d.%d.%d.%d",
+				(ntohl(nat_rule->remIP.v4) >> 24) & 0xff,
+				(ntohl(nat_rule->remIP.v4) >> 16) & 0xff,
+				(ntohl(nat_rule->remIP.v4) >> 8) & 0xff,
+				(ntohl(nat_rule->remIP.v4) >> 0) & 0xff);
+			len += slen;
+		} else {
+			slen = sprintf(buf + len,
+				"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x",
+				ntohs(nat_rule->remIP.v6.ipv6_addr16[0]),
+				ntohs(nat_rule->remIP.v6.ipv6_addr16[1]),
+				ntohs(nat_rule->remIP.v6.ipv6_addr16[2]),
+				ntohs(nat_rule->remIP.v6.ipv6_addr16[3]),
+				ntohs(nat_rule->remIP.v6.ipv6_addr16[4]),
+				ntohs(nat_rule->remIP.v6.ipv6_addr16[5]),
+				ntohs(nat_rule->remIP.v6.ipv6_addr16[6]),
+				ntohs(nat_rule->remIP.v6.ipv6_addr16[7]));
+			len += slen;
+		}
+		for (j = 0; j < (41 - slen); j++)
+			len += sprintf(buf + len, " ");
+
+		/* locMAC */
+		slen = 0;
+		for (j = 0; j < ETH_ALEN; j++) {
+			slen += sprintf(buf + len + slen, "%02x%s",
+				nat_rule->locMAC[j],
+				j < ETH_ALEN - 1 ? ":" : " ");
+		}
+		len += slen;
+		for (j = 0; j < (19 - slen); j++)
+			len += sprintf(buf + len, " ");
+
+		/* locIP */
+		if (nat_rule->typeIP == SVIP_IPV4_ADDR_TYPE) {
+			slen = sprintf(buf + len, "%d.%d.%d.%d",
+				(ntohl(nat_rule->locIP.v4) >> 24) & 0xff,
+				(ntohl(nat_rule->locIP.v4) >> 16) & 0xff,
+				(ntohl(nat_rule->locIP.v4) >> 8) & 0xff,
+				(ntohl(nat_rule->locIP.v4) >> 0) & 0xff);
+			len += slen;
+		} else {
+			slen = sprintf(buf + len,
+				"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x",
+				ntohs(nat_rule->locIP.v6.ipv6_addr16[0]),
+				ntohs(nat_rule->locIP.v6.ipv6_addr16[1]),
+				ntohs(nat_rule->locIP.v6.ipv6_addr16[2]),
+				ntohs(nat_rule->locIP.v6.ipv6_addr16[3]),
+				ntohs(nat_rule->locIP.v6.ipv6_addr16[4]),
+				ntohs(nat_rule->locIP.v6.ipv6_addr16[5]),
+				ntohs(nat_rule->locIP.v6.ipv6_addr16[6]),
+				ntohs(nat_rule->locIP.v6.ipv6_addr16[7]));
+			len += slen;
+		}
+		for (j = 0; j < (41 - slen); j++)
+			len += sprintf(buf + len, " ");
+
+		/* locUDP */
+		slen = sprintf(buf + len, "%d", ntohs(nat_rule->locUDP));
+		len += slen;
+		for (j = 0; j < (9 - slen); j++)
+			len += sprintf(buf + len, " ");
+
+		/* NAT statistics, Local to Remote translation */
+		slen = sprintf(buf + len, "(%ld/%ld/%ld)",
+			nat_table[pos].nat_stats[SVIP_NAT_STATS_LOC2REM].
+			in_packets,
+			nat_table[pos].nat_stats[SVIP_NAT_STATS_LOC2REM].
+			out_packets,
+			nat_table[pos].nat_stats[SVIP_NAT_STATS_LOC2REM].
+			out_errors);
+		len += slen;
+		for (j = 0; j < (22 - slen); j++)
+			len += sprintf(buf + len, " ");
+
+		/* NAT statistics, Remote to Local translation */
+		len += sprintf(buf + len, "(%ld/%ld/%ld)\n\r",
+			nat_table[pos].nat_stats[SVIP_NAT_STATS_REM2LOC].
+			in_packets,
+			nat_table[pos].nat_stats[SVIP_NAT_STATS_REM2LOC].
+			out_packets,
+			nat_table[pos].nat_stats[SVIP_NAT_STATS_REM2LOC].
+			out_errors);
+
+		return len;
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK
+
+/**
+
+ Read allowed destination IPs from the driver.
+
+ \param s
+ \param pos  IP entry to print
+
+ \return
+ zero or an error code
+ */
+static int SVIP_NAT_proc_read_dest_IP(struct seq_file *s, int pos)
+{
+	if (pos < nat_dest_IPv4_size + nat_dest_IPv6_size)
+		return SVIP_NAT_read_dest_IP((char *) s, 0, pos);
+	else
+		return 0;
+}
+
+/******************************************************************************/
+/**
+ Function for reading /proc/net/svip_nat/destip
+
+ \arguments
+ buf   - pointer to read buffer or seq_file structure
+ count - size of read buffer. If size is 0 then buf is pointer to seq_file
+ structure
+ pos   - IP entry to print
+
+ \return
+ if buf is pointer to buffer, length of read data into buffer, else 0 or error
+ code
+*******************************************************************************/
+static int SVIP_NAT_read_dest_IP(char *buf, int count, int pos)
+{
+	if (count == 0) {
+		/* write to seq_file */
+		struct seq_file *s = (struct seq_file *) buf;
+
+		if (pos == 0)
+			seq_printf(s,
+				"Allowed NAT destination IP addresses:\n\r");
+		if (pos < nat_dest_IPv4_size)
+		{
+			seq_printf(s, "%d.%d.%d.%d\n\r",
+				(ntohl(nat_dest_IPv4[pos]) >> 24) & 0xff,
+				(ntohl(nat_dest_IPv4[pos]) >> 16) & 0xff,
+				(ntohl(nat_dest_IPv4[pos]) >> 8) & 0xff,
+				(ntohl(nat_dest_IPv4[pos]) >> 0) & 0xff);
+		}
+		else
+			seq_printf(s,
+				"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\n\r",
+				ntohs(nat_dest_IPv6[pos - nat_dest_IPv4_size].
+					ipv6_addr16[0]),
+				ntohs(nat_dest_IPv6[pos - nat_dest_IPv4_size].
+					ipv6_addr16[1]),
+				ntohs(nat_dest_IPv6[pos - nat_dest_IPv4_size].
+					ipv6_addr16[2]),
+				ntohs(nat_dest_IPv6[pos - nat_dest_IPv4_size].
+					ipv6_addr16[3]),
+				ntohs(nat_dest_IPv6[pos - nat_dest_IPv4_size].
+					ipv6_addr16[4]),
+				ntohs(nat_dest_IPv6[pos - nat_dest_IPv4_size].
+					ipv6_addr16[5]),
+				ntohs(nat_dest_IPv6[pos - nat_dest_IPv4_size].
+					ipv6_addr16[6]),
+				ntohs(nat_dest_IPv6[pos - nat_dest_IPv4_size].
+					ipv6_addr16[7]));
+	} else {
+		int len = 0;
+
+		if (pos == 0)
+			len = sprintf(buf + len,
+				"Allowed NAT destination IP addresses:\n\r");
+
+		if (pos < nat_dest_IPv4_size) {
+			/* make sure not to overwrite the buffer */
+			if (count < len + 18) {
+				pr_err("SVIP NAT: Only part of the text could be put into the buffer\n");
+				return len;
+			}
+			len += sprintf(buf + len, "%d.%d.%d.%d\n\r",
+				(ntohl(nat_dest_IPv4[pos]) >> 24) & 0xff,
+				(ntohl(nat_dest_IPv4[pos]) >> 16) & 0xff,
+				(ntohl(nat_dest_IPv4[pos]) >> 8) & 0xff,
+				(ntohl(nat_dest_IPv4[pos]) >> 0) & 0xff);
+		} else {
+			/* make sure not to overwrite the buffer */
+			if (count < len + 42) {
+				pr_err("SVIP NAT: Only part of the text could be put into the buffer\n");
+				return len;
+			}
+			len += sprintf(buf + len,
+				"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\n\r",
+				ntohs(nat_dest_IPv6[pos - nat_dest_IPv4_size].
+					ipv6_addr16[0]),
+				ntohs(nat_dest_IPv6[pos - nat_dest_IPv4_size].
+					ipv6_addr16[1]),
+				ntohs(nat_dest_IPv6[pos - nat_dest_IPv4_size].
+					ipv6_addr16[2]),
+				ntohs(nat_dest_IPv6[pos - nat_dest_IPv4_size].
+					ipv6_addr16[3]),
+				ntohs(nat_dest_IPv6[pos - nat_dest_IPv4_size].
+					ipv6_addr16[4]),
+				ntohs(nat_dest_IPv6[pos - nat_dest_IPv4_size].
+					ipv6_addr16[5]),
+				ntohs(nat_dest_IPv6[pos - nat_dest_IPv4_size].
+					ipv6_addr16[6]),
+				ntohs(nat_dest_IPv6[pos	 - nat_dest_IPv4_size].
+					ipv6_addr16[7]));
+		}
+		return len;
+	}
+	return 0;
+}
+#endif /* CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK */
+
+/******************************************************************************/
+/**
+ Function for reading /proc/net/svip_nat/portbase
+
+ \arguments
+ s
+
+ \return
+ none
+
+ \remarks:
+ ******************************************************************************/
+static void SVIP_NAT_proc_read_port_base(struct seq_file *s)
+{
+	seq_printf(s, "%d\n\r", nat_udp_port_base);
+}
+
+#ifdef CONFIG_SVIP_FW_PKT_SNIFFER
+/**
+ Converts MAC address from ASCII to hexadecimal representation
+ */
+static int SVIP_NAT_MAC_ASCII_2_hex(const char *MAC_str, unsigned char *MAC_hex)
+{
+	int i = 0, c = 0, b = 0, n = 0;
+
+	memset(MAC_hex, 0, ETH_ALEN);
+	while (MAC_str[i] != '\0') {
+		if (n >= 0) {
+			unsigned char to_hex = 0;
+
+			/* check for hex digit */
+			if (MAC_str[i] >= '0' && MAC_str[i] <= '9')
+				to_hex = 0x30;
+			else if (MAC_str[i] >= 'a' && MAC_str[i] <= 'f')
+				to_hex = 0x57;
+			else if (MAC_str[i] >= 'A' && MAC_str[i] <= 'F')
+				to_hex = 0x37;
+			else {
+				if (n != 0) {
+					pr_err("SVIP NAT: invalid MAC address format[%s]\n",
+						MAC_str);
+					return -1;
+				}
+				i++;
+				continue;
+			}
+			n ^= 1;
+			MAC_hex[b] |= ((MAC_str[i] - to_hex)&0xf) << (4*n);
+			if (n == 0) {
+				/* advance to next byte, check if complete */
+				if (++b >= ETH_ALEN)
+					return 0;
+				/* byte completed, next we expect a colon... */
+				c = 1;
+				/* and, do not check for hex digit */
+				n = -1;
+			}
+			i++;
+			continue;
+		}
+		if (c == 1) {
+			if (MAC_str[i] == ':') {
+				/* next we expect hex digit, again */
+				n = 0;
+			} else {
+				pr_err("SVIP NAT: invalid MAC address format[%s]\n",
+					MAC_str);
+				return -1;
+			}
+		}
+		i++;
+	}
+	return 0;
+}
+
+/**
+ Used to set the destination MAC address of a host where incoming
+ SVIP VoFW packets are to be addressed. In case the address is set
+ to 00:00:00:00:00:00 (the default case), the packets will written
+ out to eth0 with its original MAC addess.
+
+ \remark
+ usage: 'echo "00:03:19:00:15:D1" > cat /proc/net/svip_nat/snifferMAC'
+ */
+static ssize_t SVIP_NAT_proc_write_sniffer_MAC(struct file *file,
+	const char __user *buffer, size_t count, loff_t *data)
+{
+	/* at least strlen("xx:xx:xx:xx:xx:xx") characters, followed by '\0' */
+	if (count >= 18) {
+		int ret;
+
+		ret = SVIP_NAT_MAC_ASCII_2_hex(buffer, SVIP_NAT_sniffer_MAC);
+
+		if (ret != 0)
+			return 0;
+
+		if (!(SVIP_NAT_sniffer_MAC[0] == 0 &&
+			SVIP_NAT_sniffer_MAC[1] == 0 &&
+			SVIP_NAT_sniffer_MAC[2] == 0 &&
+			SVIP_NAT_sniffer_MAC[3] == 0 &&
+			SVIP_NAT_sniffer_MAC[4] == 0 &&
+			SVIP_NAT_sniffer_MAC[5] == 0))
+			SVIP_NAT_sniffer_MAC_set = 1;
+	}
+	return count;
+}
+
+/******************************************************************************/
+/**
+ Function for reading /proc/net/svip_nat/snifferMAC
+
+ \arguments
+ \param s
+
+ \return
+ none
+
+ \remarks:
+ ******************************************************************************/
+static void SVIP_NAT_proc_read_sniffer_MAC(struct seq_file *s)
+{
+	seq_printf(s, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+		SVIP_NAT_sniffer_MAC[0], SVIP_NAT_sniffer_MAC[1],
+		SVIP_NAT_sniffer_MAC[2], SVIP_NAT_sniffer_MAC[3],
+		SVIP_NAT_sniffer_MAC[4], SVIP_NAT_sniffer_MAC[5]);
+}
+
+/**
+ Used to switch VoFW message sniffer on/off
+
+ \remark
+ usage: 'echo "1" > cat /proc/net/svip_nat/snifferOnOff'
+ */
+static ssize_t SVIP_NAT_proc_write_sniffer_on_off(struct file *file,
+	const char __user *buffer,
+	size_t count, loff_t *data)
+{
+	/* at least one digit expected, followed by '\0' */
+	if (count >= 2) {
+		int ret, sniffer;
+
+		ret = sscanf(buffer, "%d", &sniffer);
+
+		if (ret != 1)
+			return count;
+
+		if (sniffer > 0)
+			sniffer = 1;
+
+		SVIP_NAT_sniffer = sniffer;
+	}
+	return count;
+}
+
+/******************************************************************************/
+/**
+ Function for reading /proc/net/svip_nat/snifferOnOff
+
+ \arguments
+ \param s
+
+ \return
+ none
+
+ \remarks:
+*******************************************************************************/
+static void SVIP_NAT_proc_read_sniffer_on_off(struct seq_file *s)
+{
+	seq_printf(s, "%d\n", SVIP_NAT_sniffer);
+}
+#endif
+
+static void *SVIP_NAT_seq_start(struct seq_file *s, loff_t *pos)
+{
+	struct proc_file_entry *p = s->private;
+
+	if (*pos == 0 || *pos > p->max_pos)
+		down(sem_nat_tbl_access);
+
+	if (*pos > p->max_pos || *pos < 0)
+		return NULL;
+
+	/* set current position */
+	p->pos = *pos;
+
+	return p;
+}
+
+static void *SVIP_NAT_seq_next(struct seq_file *s, void *v, loff_t *pos)
+{
+	struct proc_file_entry *p = s->private;
+
+	(*pos)++;
+	p->pos = *pos;
+	if (*pos > p->max_pos || *pos < 0)
+		return NULL;
+
+	return p;
+}
+
+static void SVIP_NAT_seq_stop(struct seq_file *s, void *v)
+{
+	struct proc_file_entry *p = s->private;
+
+	if (p->pos > p->max_pos)
+		up(sem_nat_tbl_access);
+}
+
+static int SVIP_NAT_seq_show(struct seq_file *s, void *v)
+{
+	struct proc_file_entry *p = s->private;
+
+	return p->callback(s, p->pos);
+}
+
+static int SVIP_NAT_proc_open(struct inode *inode, struct file *file)
+{
+	struct seq_file *s;
+	struct proc_file_entry *p;
+	struct proc_entry *entry;
+	int ret;
+
+	ret = seq_open(file, &SVIP_NAT_seq_ops);
+	if (ret)
+		return ret;
+
+	s = file->private_data;
+	p = kmalloc(sizeof(*p), GFP_KERNEL);
+
+	if (!p) {
+		(void) seq_release(inode, file);
+		return -ENOMEM;
+	}
+
+	entry = PDE_DATA(inode);
+
+	p->callback = entry->callback;
+	if (entry->callback)
+		p->max_pos = entry->max_pos;
+	else
+		p->max_pos = 0;
+
+	s->private = p;
+
+	return 0;
+}
+
+static int SVIP_NAT_proc_release(struct inode *inode, struct file *file)
+{
+	struct seq_file *s;
+
+	s = file->private_data;
+	kfree(s->private);
+
+	return seq_release(inode, file);
+}
+
+static int SVIP_NAT_seq_single_show(struct seq_file *s, void *v)
+{
+	struct proc_entry *p = s->private;
+
+	p->single_callback(s);
+	return 0;
+}
+
+static int SVIP_NAT_proc_single_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, SVIP_NAT_seq_single_show, PDE_DATA(inode));
+}
+
+static void SVIP_NAT_proc_entry_create(struct proc_dir_entry *parent_node,
+	struct proc_entry *proc_entry)
+{
+	mode_t mode = S_IFREG | S_IRUGO;
+
+	memset(&proc_entry->ops, 0, sizeof(const struct file_operations));
+	proc_entry->ops.owner = THIS_MODULE;
+
+	if (proc_entry->single_callback) {
+		proc_entry->ops.open = SVIP_NAT_proc_single_open;
+		proc_entry->ops.release = single_release;
+	} else {
+		proc_entry->ops.open = SVIP_NAT_proc_open;
+		proc_entry->ops.release = SVIP_NAT_proc_release;
+	}
+
+	proc_entry->ops.read = seq_read;
+	proc_entry->ops.write = proc_entry->write_function;
+	if (proc_entry->write_function != NULL)
+		mode |= S_IWUGO;
+	proc_entry->ops.llseek = seq_lseek;
+
+	proc_create_data(proc_entry->name, mode, parent_node, &proc_entry->ops,
+		proc_entry);
+}
+
+/******************************************************************************/
+/**
+ Creates proc read/write entries
+
+ \return
+ 0 on success, -1 on error
+ */
+/******************************************************************************/
+static int SVIP_NAT_proc_install(void)
+{
+	struct proc_dir_entry *proc_parent_dir, *proc_dir;
+	int i;
+
+	proc_parent_dir = init_net.proc_net;
+	proc_dir = proc_mkdir(SVIP_NAT_DEVICE_NAME, proc_parent_dir);
+	if (proc_dir == NULL) {
+		pr_err("SVIP NAT: cannot create "SVIP_NAT_DEVICE_NAME
+			" proc directory\n\r");
+		return -1;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(proc_entries); i++)
+		SVIP_NAT_proc_entry_create(proc_dir, &proc_entries[i]);
+#ifdef CONFIG_SVIP_FW_PKT_SNIFFER
+	SVIP_NAT_sniffer = 0;
+	memset(SVIP_NAT_sniffer_MAC, 0, ETH_ALEN);
+	SVIP_NAT_sniffer_MAC_set = 0;
+#endif
+
+	return 0;
+}
+
+/******************************************************************************/
+/**
+ No actions done here, simply a check is performed if an open has already
+ been performed. Currently only a single open is allowed as it is a sufficient
+ to have hat a single process configuring the SVIP NAT at one time.
+
+ \arguments
+ inode   - pointer to disk file data
+ file    - pointer to device file data
+
+ \return
+ 0 on success, else -1
+ */
+/******************************************************************************/
+static int SVIP_NAT_device_open(struct inode *inode, struct file *file)
+{
+	unsigned long flags;
+	struct in_device *in_dev;
+	struct inet6_dev *in_dev_ip6;
+	struct in_ifaddr *ifa;
+	struct inet6_ifaddr *ifa_ip6;
+
+	local_save_flags(flags);
+	if (device_open) {
+		local_irq_restore(flags);
+		return 0;
+	}
+
+	/* find pointer to IP address of eth0 */
+	in_dev = in_dev_get(net_devs[SVIP_NET_DEV_ETH0_IDX]);
+	if (in_dev) {
+		for (ifa = in_dev->ifa_list; ifa != NULL; ifa = ifa->ifa_next) {
+			if (ifa->ifa_address != 0) {
+				paddr_eth0 = &ifa->ifa_address;
+				break;
+			}
+		}
+		in_dev_put(in_dev);
+	}
+	if (paddr_eth0 == NULL) {
+		local_irq_restore(flags);
+		return -ENODATA;
+	}
+	/* find pointer to IPv6 address of eth0 */
+	in_dev_ip6 = in6_dev_get(net_devs[SVIP_NET_DEV_ETH0_IDX]);
+	if (in_dev_ip6) {
+		read_lock_bh(&in_dev_ip6->lock);
+		list_for_each_entry(ifa_ip6, &in_dev_ip6->addr_list, if_list) {
+			if (!ipv6_addr_any(&ifa_ip6->addr)) {
+				paddr_eth0_ip6 = &ifa_ip6->addr;
+				prefix_len_eth0 = ifa_ip6->prefix_len;
+				break;
+			}
+		}
+		read_unlock_bh(&in_dev_ip6->lock);
+		in6_dev_put(in_dev_ip6);
+	}
+	if (ipv6_addr_any(paddr_eth0_ip6)) {
+		local_irq_restore(flags);
+		return -ENODATA;
+	}
+
+	/* find pointer to IP address of eth1 */
+	in_dev = in_dev_get(net_devs[SVIP_NET_DEV_ETH1_IDX]);
+	if (in_dev) {
+		for (ifa = in_dev->ifa_list; ifa != NULL; ifa = ifa->ifa_next) {
+			if (ifa->ifa_address != 0) {
+				paddr_eth1 = &ifa->ifa_address;
+				pmask_eth1 = &ifa->ifa_mask;
+				break;
+			}
+		}
+		in_dev_put(in_dev);
+	}
+	if (paddr_eth1 == NULL) {
+		local_irq_restore(flags);
+		return -ENODATA;
+	}
+	/* find pointer to IPv6 address of eth1 */
+	in_dev_ip6 = in6_dev_get(net_devs[SVIP_NET_DEV_ETH1_IDX]);
+	if (in_dev_ip6) {
+		read_lock_bh(&in_dev_ip6->lock);
+		list_for_each_entry(ifa_ip6, &in_dev_ip6->addr_list, if_list) {
+			if (!ipv6_addr_any(&ifa_ip6->addr)) {
+				paddr_eth1_ip6 = &ifa_ip6->addr;
+				break;
+			}
+		}
+		read_unlock_bh(&in_dev_ip6->lock);
+		in6_dev_put(in_dev_ip6);
+	}
+	if (ipv6_addr_any(paddr_eth1_ip6)) {
+		local_irq_restore(flags);
+		return -ENODATA;
+	}
+
+	/* find pointer to IP address of veth0 */
+	in_dev = in_dev_get(net_devs[SVIP_NET_DEV_VETH0_IDX]);
+	if (in_dev) {
+		for (ifa = in_dev->ifa_list; ifa != NULL; ifa = ifa->ifa_next) {
+			if (ifa->ifa_address != 0) {
+				paddr_veth0 = &ifa->ifa_address;
+				pmask_veth0 = &ifa->ifa_mask;
+				break;
+			}
+		}
+		in_dev_put(in_dev);
+	}
+	if (paddr_veth0 == NULL) {
+		local_irq_restore(flags);
+		return -ENODATA;
+	}
+	/* find pointer to IPv6 address of veth0 and set its prefix length */
+	in_dev_ip6 = in6_dev_get(net_devs[SVIP_NET_DEV_VETH0_IDX]);
+	if (in_dev_ip6) {
+		read_lock_bh(&in_dev_ip6->lock);
+		list_for_each_entry(ifa_ip6, &in_dev_ip6->addr_list, if_list) {
+			if (!ipv6_addr_any(&ifa_ip6->addr)) {
+				paddr_veth0_ip6 = &ifa_ip6->addr;
+				prefix_len_veth0 = ifa_ip6->prefix_len;
+				break;
+			}
+		}
+		read_unlock_bh(&in_dev_ip6->lock);
+		in6_dev_put(in_dev_ip6);
+	}
+	if (paddr_veth0_ip6 != NULL && ipv6_addr_any(paddr_veth0_ip6)) {
+		local_irq_restore(flags);
+		return -ENODATA;
+	}
+
+	device_open++;
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+/******************************************************************************/
+/**
+ This function is called when a process closes the SVIP NAT device file
+
+ \arguments
+ inode   - pointer to disk file data
+ file    - pointer to device file data
+
+ \return
+ 0 on success, else -1
+
+ */
+/******************************************************************************/
+static int SVIP_NAT_device_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+
+/******************************************************************************/
+/**
+ This function is called when a process closes the SVIP NAT device file
+
+ \arguments
+ inode          - pointer to disk file data
+ file           - pointer to device file data
+ ioctl_num      - ioctl number requested
+ ioctl_param    - pointer to data related to the ioctl number
+
+ \return
+ 0 on success, else -1
+
+ */
+/******************************************************************************/
+long SVIP_NAT_device_ioctl(struct file *file, unsigned int ioctl_num,
+	unsigned long ioctl_param)
+{
+	int ret = 0;
+	SVIP_NAT_IO_Rule_t *nat_rule, *NAT_rule_in;
+	SVIP_UDP_PORT_t port;
+	int NAT_idx;
+	int write = 0;
+	int read = 0;
+	unsigned char *data = 0;
+	int size;
+
+	if (_IOC_DIR(ioctl_num) & _IOC_WRITE)
+		write = 1;
+	if (_IOC_DIR(ioctl_num) & _IOC_READ)
+		read = 1;
+	size = _IOC_SIZE(ioctl_num);
+
+	if (size > 0) {
+		if (read || write) {
+			data = kmalloc(size, GFP_KERNEL);
+			if (write) {
+				if (copy_from_user((void *)data,
+					(void *)ioctl_param, size) != 0) {
+					pr_err("SVIP NAT: ioctl %x: copy_from_user() failed!\n",
+						ioctl_num);
+					ret = -1;
+					goto error;
+				}
+			}
+		}
+	}
+
+	switch (ioctl_num) {
+	case FIO_SVIP_NAT_RULE_ADD:
+
+		NAT_rule_in = (SVIP_NAT_IO_Rule_t *) data;
+
+		/* check if destination UDP port is within range */
+		port = ntohs(NAT_rule_in->locUDP);
+
+		if (!SVIP_PORT_INRANGE(port)) {
+			pr_err("SVIP NAT: Error, UDP port(%d) is out of range(%d..%d)\n",
+				port, SVIP_UDP_FROM, SVIP_UDP_TO);
+			ret = -1;
+			goto error;
+		}
+		NAT_idx = SVIP_PORT_INDEX(port);
+
+		down(sem_nat_tbl_access);
+		nat_rule = &nat_table[NAT_idx].nat_rule;
+
+		/* add rule to the NAT table */
+		nat_rule->typeIP = NAT_rule_in->typeIP;
+		if (NAT_rule_in->typeIP == SVIP_IPV4_ADDR_TYPE) {
+			nat_rule->remIP = NAT_rule_in->remIP;
+			nat_rule->locIP = NAT_rule_in->locIP;
+		} else {
+			nat_rule->remIP.v6 = NAT_rule_in->remIP.v6;
+			nat_rule->locIP.v6 = NAT_rule_in->locIP.v6;
+		}
+		memcpy((char *)nat_rule->remMAC, (char *)NAT_rule_in->remMAC,
+			ETH_ALEN);
+		memcpy((char *)nat_rule->locMAC, (char *)NAT_rule_in->locMAC,
+			ETH_ALEN);
+		nat_rule->locUDP = NAT_rule_in->locUDP;
+
+		memset(nat_table[NAT_idx].nat_stats, 0,
+			sizeof(struct SVIP_NAT_stats)*SVIP_NAT_STATS_TYPES);
+		up(sem_nat_tbl_access);
+		break;
+
+	case FIO_SVIP_NAT_RULE_REMOVE:
+
+		NAT_rule_in = (SVIP_NAT_IO_Rule_t *) data;
+
+		/* check if destination UDP port is within range */
+		port = ntohs(NAT_rule_in->locUDP);
+		if (!SVIP_PORT_INRANGE(port)) {
+			pr_err("SVIP NAT: Error, UDP port(%d) is out of range(%d..%d)\n",
+				port, SVIP_UDP_FROM, SVIP_UDP_TO);
+			ret = -1;
+			goto error;
+		}
+		NAT_idx = SVIP_PORT_INDEX(port);
+		down(sem_nat_tbl_access);
+		/* remove rule from the NAT table */
+		memset(&nat_table[NAT_idx], 0,
+			sizeof(struct SVIP_NAT_table_entry));
+		up(sem_nat_tbl_access);
+		break;
+
+	case FIO_SVIP_NAT_RULE_LIST:
+	{
+		int i, len;
+		char buf[256];
+
+		down(sem_nat_tbl_access);
+		for (i = 0; i < CONFIG_LTQ_SVIP_NAT_RULES_TOTAL; i++) {
+			len = SVIP_NAT_read_NAT(buf, sizeof(buf), i);
+			if (len > 0)
+				pr_notice("%s", buf);
+		}
+		up(sem_nat_tbl_access);
+		break;
+	}
+
+#ifdef CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK
+	case FIO_SVIP_NAT_DESTIP_CHECK_ADD:
+	{
+		int i;
+
+		down(sem_nat_tbl_access);
+		if (((SVIP_NAT_DESTIP_t *) data)->typeIP ==
+			SVIP_IPV4_ADDR_TYPE) {
+			for (i = 0; i < nat_dest_IPv4_size; i++)
+				if (nat_dest_IPv4[i]
+					== ((SVIP_NAT_DESTIP_t *) data)->IP.v4)
+					break;
+			if (i < CONFIG_LTQ_SVIP_NAT_DESTIP_LIST_SIZE) {
+
+				nat_dest_IPv4[i] =
+					((SVIP_NAT_DESTIP_t *) data)->IP.v4;
+				nat_dest_IPv4_size =
+					i >= nat_dest_IPv4_size ? i + 1 :
+						nat_dest_IPv4_size;
+			} else {
+				up(sem_nat_tbl_access);
+				pr_err("SVIP NAT: Error, valid IPv4 address list full\n");
+				ret = -1;
+				goto error;
+			}
+		} else {
+			for (i = 0; i < nat_dest_IPv6_size; i++)
+				if (!ipv6_addr_cmp(
+					(struct in6_addr *) &nat_dest_IPv6[i],
+					(struct in6_addr *)
+					&((SVIP_NAT_DESTIP_t *) data)->IP.v6))
+					break;
+			if (i < CONFIG_LTQ_SVIP_NAT_DESTIP_LIST_SIZE) {
+				nat_dest_IPv6[i] =
+					((SVIP_NAT_DESTIP_t *) data)->IP.v6;
+				nat_dest_IPv6_size =
+					i >= nat_dest_IPv6_size ? i + 1 :
+						nat_dest_IPv6_size;
+			} else {
+				up(sem_nat_tbl_access);
+				pr_err("SVIP NAT: Error, valid IPv6 address list full\n");
+				ret = -1;
+				goto error;
+			}
+		}
+		up(sem_nat_tbl_access);
+		break;
+	}
+
+	case FIO_SVIP_NAT_DESTIP_CHECK_REMOVE:
+	{
+		int i;
+
+		down(sem_nat_tbl_access);
+		if (((SVIP_NAT_DESTIP_t *) data)->typeIP ==
+			SVIP_IPV4_ADDR_TYPE) {
+			for (i = 0; i < nat_dest_IPv4_size; i++)
+				if (nat_dest_IPv4[i]
+					== ((SVIP_NAT_DESTIP_t *) data)->IP.v4)
+					break;
+			if (i < nat_dest_IPv4_size) {
+				/* element found, remove it */
+				nat_dest_IPv4[i] = 0;
+				/* move last element to position of removed
+				 * element, decrease size by 1
+				 */
+				nat_dest_IPv4_size--;
+				nat_dest_IPv4[i] =
+					nat_dest_IPv4[nat_dest_IPv4_size];
+			}
+		} else {
+			for (i = 0; i < nat_dest_IPv6_size; i++)
+				if (!ipv6_addr_cmp(
+					(struct in6_addr *) &nat_dest_IPv6[i],
+					(struct in6_addr *)
+					&((SVIP_NAT_DESTIP_t *) data)->IP.v6))
+					break;
+			if (i < nat_dest_IPv6_size) {
+				/* element found, remove it */
+				ipv6_addr_set(
+					(struct in6_addr *) &nat_dest_IPv6[i],
+					0, 0, 0, 0);
+				/* move last element to position of removed
+				 * element, decrease size by 1
+				 */
+				nat_dest_IPv6_size--;
+				nat_dest_IPv6[i] =
+					nat_dest_IPv6[nat_dest_IPv6_size];
+			}
+		}
+		up(sem_nat_tbl_access);
+		break;
+	}
+	case FIO_SVIP_NAT_DESTIP_LIST_GET:
+	{
+		int len, i;
+		char buf[90];
+
+		down(sem_nat_tbl_access);
+		for (i = 0; i < nat_dest_IPv4_size + nat_dest_IPv6_size; i++) {
+			len = SVIP_NAT_read_dest_IP(buf, sizeof(buf), i);
+			if (len > 0)
+				pr_notice("%s", buf);
+		}
+		up(sem_nat_tbl_access);
+		break;
+	}
+#endif /* CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK */
+	case FIO_SVIP_NAT_UDP_PORT_BASE_SET:
+	{
+		int i;
+
+		down(sem_nat_tbl_access);
+		for (i = 0; i < CONFIG_LTQ_SVIP_NAT_RULES_TOTAL; i++) {
+			if (nat_table[i].nat_rule.locUDP != 0)
+				break;
+		}
+		if (i < CONFIG_LTQ_SVIP_NAT_RULES_TOTAL) {
+			up(sem_nat_tbl_access);
+			pr_err("SVIP NAT: Error. NAT table not empty. Changing NAT UDP base port number not possible\n");
+			ret = -1;
+			goto error;
+		}
+		nat_udp_port_base = *(SVIP_UDP_PORT_t *) data;
+		up(sem_nat_tbl_access);
+		break;
+	}
+	case FIO_SVIP_NAT_UDP_PORT_BASE_GET:
+	{
+		*(SVIP_UDP_PORT_t *) data = nat_udp_port_base;
+		break;
+	}
+	default:
+		pr_err("SVIP NAT: unsupported ioctl (%x) command for device %s\n",
+			ioctl_num, PATH_SVIP_NAT_DEVICE_NAME);
+		ret = -1;
+		goto error;
+	}
+
+	if (size > 0) {
+		if (read) {
+			if (copy_to_user((void *)ioctl_param, (void *)data,
+				size) != 0) {
+				pr_err("SVIP NAT: ioctl %x: copy_to_user() failed!\n",
+					ioctl_num);
+				ret = -1;
+				goto error;
+			}
+		}
+	}
+
+error: kfree(data);
+
+	return ret;
+}
+
+#if 0
+void dump_msg(unsigned char *data, unsigned int len)
+{
+	int i;
+
+	for (i = 0; i < len; i++) {
+		if (!i || !(i%16))
+			pr_notice("\n	 ");
+		else if (i && !(i%4))
+			printk(" ");
+		pr_notice("%02x", data[i]);
+	}
+	if (--i%16)
+		pr_notice("\n");
+}
+#endif
+
+/******************************************************************************/
+/**
+ Used to recalculate IP/UDP checksum using the original IP/UDP checksum
+ coming with the packet. The original source and destination IP addresses
+ are accounted for, and, the checksum is updated using the new source and
+ destination IP addresses.
+
+ \arguments
+ skb          - pointer to the receiving socket buffer
+ csum_old     - original checksum
+ saddr_old    - pointer to original source IP address
+ saddr_new    - pointer to new source IP address
+ daddr_old    - pointer to original destination IP address
+ daddr_new    - pointer to new destination IP address
+
+ \return
+ recalculated IP/UDP checksum
+ \remark
+ for IPv4
+ */
+/******************************************************************************/
+static inline u16 ip_udp_quick_csum(u16 csum_old, u16 *saddr_old,
+	u16 *saddr_new, u16 *daddr_old, u16 *daddr_new)
+{
+	u32 sum;
+
+	sum = csum_old;
+
+	/* convert back from one's complement */
+	sum = ~sum & 0xffff;
+
+	if (sum < saddr_old[0])
+		sum += 0xffff;
+	sum -= saddr_old[0];
+	if (sum < saddr_old[1])
+		sum += 0xffff;
+	sum -= saddr_old[1];
+	if (sum < daddr_old[0])
+		sum += 0xffff;
+	sum -= daddr_old[0];
+	if (sum < daddr_old[1])
+		sum += 0xffff;
+	sum -= daddr_old[1];
+
+	sum += saddr_new[0];
+	sum += saddr_new[1];
+	sum += daddr_new[0];
+	sum += daddr_new[1];
+
+	/* take only 16 bits out of the 32 bit sum and add up the carries */
+	while (sum >> 16)
+		sum = (sum & 0xffff) + ((sum >> 16) & 0xffff);
+
+	/* one's complement the result */
+	sum = ~sum;
+
+	return (u16) (sum & 0xffff);
+}
+
+/******************************************************************************/
+/**
+ Used to recalculate IP/UDP checksum using the original IP/UDP checksum
+ coming with the packet. The original source and destination IP addresses
+ are accounted for, and, the checksum is updated using the new source and
+ destination IP addresses.
+
+ \arguments
+ skb          - pointer to the receiving socket buffer
+ csum_old     - original checksum
+ saddr_old    - pointer to original source IP address
+ saddr_new    - pointer to new source IP address
+ daddr_old    - pointer to original destination IP address
+ daddr_new    - pointer to new destination IP address
+
+ \return
+ recalculated IP/UDP checksum
+ \remark
+ for IPv6
+ */
+/******************************************************************************/
+static inline u16 ip6_udp_quick_csum(u16 csum_old, u16 *saddr_old,
+	u16 *saddr_new, u16 *daddr_old, u16 *daddr_new)
+{
+	u32 sum;
+
+	sum = csum_old;
+
+	/* convert back from one's complement */
+	sum = ~sum & 0xffff;
+
+	if (sum < saddr_old[0])
+		sum += 0xffff;
+	sum -= saddr_old[0];
+	if (sum < saddr_old[1])
+		sum += 0xffff;
+	sum -= saddr_old[1];
+	if (sum < saddr_old[2])
+		sum += 0xffff;
+	sum -= saddr_old[2];
+	if (sum < saddr_old[3])
+		sum += 0xffff;
+	sum -= saddr_old[3];
+	if (sum < saddr_old[4])
+		sum += 0xffff;
+	sum -= saddr_old[4];
+	if (sum < saddr_old[5])
+		sum += 0xffff;
+	sum -= saddr_old[5];
+	if (sum < saddr_old[6])
+		sum += 0xffff;
+	sum -= saddr_old[6];
+	if (sum < saddr_old[7])
+		sum += 0xffff;
+	sum -= saddr_old[7];
+
+	if (sum < daddr_old[0])
+		sum += 0xffff;
+	sum -= daddr_old[0];
+	if (sum < daddr_old[1])
+		sum += 0xffff;
+	sum -= daddr_old[1];
+	if (sum < daddr_old[2])
+		sum += 0xffff;
+	sum -= daddr_old[2];
+	if (sum < daddr_old[3])
+		sum += 0xffff;
+	sum -= daddr_old[3];
+	if (sum < daddr_old[4])
+		sum += 0xffff;
+	sum -= daddr_old[4];
+	if (sum < daddr_old[5])
+		sum += 0xffff;
+	sum -= daddr_old[5];
+	if (sum < daddr_old[6])
+		sum += 0xffff;
+	sum -= daddr_old[6];
+	if (sum < daddr_old[7])
+		sum += 0xffff;
+	sum -= daddr_old[7];
+
+	sum += saddr_new[0];
+	sum += saddr_new[1];
+	sum += saddr_new[2];
+	sum += saddr_new[3];
+	sum += saddr_new[4];
+	sum += saddr_new[5];
+	sum += saddr_new[6];
+	sum += saddr_new[7];
+	sum += daddr_new[0];
+	sum += daddr_new[1];
+	sum += daddr_new[2];
+	sum += daddr_new[3];
+	sum += daddr_new[4];
+	sum += daddr_new[5];
+	sum += daddr_new[6];
+	sum += daddr_new[7];
+
+	/* take only 16 bits out of the 32 bit sum and add up the carries */
+	while (sum >> 16)
+		sum = (sum & 0xffff) + ((sum >> 16) & 0xffff);
+
+	/* one's complement the result */
+	sum = ~sum;
+
+	return (u16) (sum & 0xffff);
+}
+
+/******************************************************************************/
+/**
+ Returns a pointer to an ipv4 address assigned to device dev.
+
+ \arguments
+ dev         - pointer to network interface
+ ppifa_addr  - output parameter
+
+ \return
+ none
+ */
+/******************************************************************************/
+static void get_ifaddr(struct net_device *dev, unsigned int **ppifa_addr)
+{
+	struct in_device *in_dev;
+	struct in_ifaddr *ifa = NULL;
+
+	in_dev = in_dev_get(dev);
+	if (in_dev) {
+		ifa = in_dev->ifa_list;
+		if (ifa)
+			*ppifa_addr = &ifa->ifa_address;
+		in_dev_put(in_dev);
+	}
+	*ppifa_addr = NULL;
+}
+
+
+#ifndef VLAN_8021Q_UNUSED
+/******************************************************************************/
+/**
+ Returns a pointer to an ipv6 address assigned to device dev.
+
+ \arguments
+ dev         - pointer to network interface
+ ppifa_addr  - output parameter
+
+ \return
+ none
+ */
+/******************************************************************************/
+static void get_inet6_ifaddr(struct net_device *dev,
+	struct in6_addr **ppifa_addr)
+{
+	struct inet6_dev *in_dev;
+	struct inet6_ifaddr *ifa = NULL;
+
+	in_dev = in6_dev_get(dev);
+	if (in_dev) {
+		read_lock_bh(&in_dev->lock);
+		list_for_each_entry(ifa, &in_dev->addr_list, if_list) {
+			if (!ipv6_addr_any(&ifa->addr)) {
+				*ppifa_addr = &ifa->addr;
+				break;
+			}
+		}
+		read_unlock_bh(&in_dev->lock);
+		in6_dev_put(in_dev);
+		return;
+	}
+	*ppifa_addr = NULL;
+}
+#endif
+
+/******************************************************************************/
+/**
+ This function performs IP NAT for received packets satisfying the
+ following requirements:
+
+ - packet is destined to local IP host
+ - transport protocol type is UDP
+ - destination UDP port is within range
+ - IPv4 NAT rule is defined for this UDP port
+
+ \arguments
+ skb - pointer to the receiving socket buffer
+
+ \return
+ returns 1 on performed SVIP NAT, else returns 0
+
+ \remarks
+ When function returns 0, it indicates the caller to pass the
+ packet up the IP stack to make further decision about it
+ */
+/******************************************************************************/
+int do_SVIP_NAT(struct sk_buff *skb)
+{
+	struct net_device *real_dev;
+	struct iphdr *iph;
+	struct udphdr *udph;
+	SVIP_NAT_IO_Rule_t *nat_rule;
+	int NAT_idx, in_eth0, dir;
+#ifndef VLAN_8021Q_UNUSED
+	int vlan;
+	unsigned short vid;
+	__be16 vlan_proto = 0;
+#endif /* ! VLAN_8021Q_UNUSED */
+	SVIP_UDP_PORT_t port;
+	u32 org_src_IP, org_ds_IP, *src_IP, *dst_IP;
+	struct ethhdr *ethh;
+#ifdef CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK
+	int i = 0;
+#endif
+
+	/* do not consider if SVIP NAT device not open. */
+	if (!device_open)
+		return 0;
+
+	/* consider only UDP packets. */
+	iph = ip_hdr(skb);
+	if (iph->protocol != IPPROTO_UDP)
+		return 0;
+
+#ifdef CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK
+	for (i = 0; i < nat_dest_IPv4_size; i++)
+		if (iph->daddr == nat_dest_IPv4[i])
+			break;
+	if (i >= nat_dest_IPv4_size)
+		return 0;
+#endif /* CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK */
+
+	udph = (struct udphdr *) ((u_int32_t *) iph + iph->ihl);
+	/* consider only packets which UDP port numbers reside within
+	 * the predefined SVIP NAT UDP port range.
+	 */
+	if ((!SVIP_PORT_INRANGE(ntohs(udph->dest)))
+		&& (!SVIP_PORT_INRANGE(ntohs(udph->source))))
+		return 0;
+
+#ifndef VLAN_8021Q_UNUSED
+	/*
+	 * check if packet delivered over VLAN. VLAN packets will be routed over
+	 * the VLAN interfaces of the respective real Ethernet interface, if one
+	 * exists(VIDs must match). Else, the packet will be send out as
+	 * IEEE 802.3 Ethernet frame
+	 */
+	if (skb->dev->priv_flags & IFF_802_1Q_VLAN) {
+		vlan = 1;
+		vid = vlan_dev_vlan_id(skb->dev);
+		real_dev = vlan_dev_real_dev(skb->dev);
+		vlan_proto = skb->vlan_proto;
+	} else {
+		vlan = 0;
+		vid = 0;
+		real_dev = skb->dev;
+	}
+#endif /* ! VLAN_8021Q_UNUSED */
+
+#ifdef CONFIG_SVIP_FW_PKT_SNIFFER
+	/*
+	 * Debugging feature which can be enabled by writing,
+	 * 'echo 1 > /proc/net/svip_nat/snifferOnOff'.
+	 * It copies all packets received on veth0 and eth1 and, sends them out
+	 * over eth0. When a destination MAC address is specified through
+	 * /proc/net/svip_nat/snifferMAC, this MAC addess will substitute the
+	 * original MAC address of the packet.
+	 * It is recommended to specify a MAC address of some host where
+	 * Wireshark runs and sniffs for this traffic, else you may flood your
+	 * LAN with undeliverable traffic.
+	 * NOTE: In case of VLAN traffic the VLAN header information is lost.
+	 */
+	if (SVIP_NAT_sniffer) {
+		if (real_dev == net_devs[SVIP_NET_DEV_VETH0_IDX] ||
+			real_dev == net_devs[SVIP_NET_DEV_ETH1_IDX]) {
+			struct sk_buff *copied_skb;
+
+			/* gain the Ethernet header from the skb */
+			skb_push(skb, ETH_HLEN);
+
+			copied_skb = skb_copy(skb, GFP_ATOMIC);
+
+			if (SVIP_NAT_sniffer_MAC_set == 1) {
+				ethh = (struct ethhdr *)
+				skb_mac_header(copied_skb);
+				memcpy((char *)ethh->h_dest,
+					(char *)SVIP_NAT_sniffer_MAC,
+					ETH_ALEN);
+			}
+			copied_skb->dev = net_devs[SVIP_NET_DEV_ETH0_IDX];
+			dev_queue_xmit(copied_skb);
+
+			/* skip the ETH header again */
+			skb_pull(skb, ETH_HLEN);
+		}
+	}
+#endif
+
+	/* check if packet arrived on eth0 */
+	if (real_dev == net_devs[SVIP_NET_DEV_ETH0_IDX]) {
+		/*
+		 * Check if destination IP address equals the IP address
+		 * of interface eth0. This is the case of packets originating
+		 * from a remote peer that are to be
+		 * delivered to a channel residing on THIS voice linecard
+		 * system. This is typical SVIP NAT case, therefore this rule is
+		 * placed on top.
+		 */
+		if (iph->daddr == *paddr_eth0)
+		{
+			port = ntohs(udph->dest);
+			dir = SVIP_NAT_STATS_REM2LOC;
+		} else
+#ifndef VLAN_8021Q_UNUSED
+		/*
+		 * check if the packet has addressed any of the IP
+		 * addresses assigned to the VLAN interface attached to
+		 * eth0. This is not recommended approach because of
+		 * the CPU cost incurred. */
+		if (vlan)
+		{
+			struct in_device *in_dev;
+			struct in_ifaddr *ifa = NULL;
+			bool bAddrHit = false;
+			int i = 0;
+
+			if ((in_dev=in_dev_get(skb->dev)) == NULL)
+				return 0;
+
+			for (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next)
+			{
+				if (iph->daddr == ifa->ifa_address)
+				{
+					bAddrHit = true;
+					break;
+				}
+				i++;
+			}
+
+			in_dev_put(in_dev);
+
+			if (bAddrHit) {
+				port = ntohs(udph->dest);
+				dir = SVIP_NAT_STATS_REM2LOC;
+			} else
+				return 0;
+		} else
+#endif /* ! VLAN_8021Q_UNUSED */
+			return 0;
+		in_eth0 = 1;
+	} else if (real_dev == net_devs[SVIP_NET_DEV_ETH1_IDX]) {
+		/* check if packet arrived on eth1 */
+		/*
+		 * Packets originating from slave and destined to master or the
+		 * same slave
+		 */
+		if (iph->daddr == *paddr_eth1)
+		{
+			port = ntohs(udph->dest);
+			dir = SVIP_NAT_STATS_REM2LOC;
+		} else
+#ifndef VLAN_8021Q_UNUSED
+		/*
+		 * check if the packet has addressed any of the IP
+		 * addresses assigned to the VLAN interface attached to
+		 * eth0. This is not recommended approach because of
+		 * the CPU cost incurred. */
+		if (vlan)
+		{
+			struct in_device *in_dev;
+			struct in_ifaddr *ifa = NULL;
+			bool bAddrHit = false;
+			int i = 0;
+
+			if ((in_dev=in_dev_get(skb->dev)) == NULL)
+				return 0;
+
+			for (ifa = in_dev->ifa_list; ifa; ifa = ifa->ifa_next)
+			{
+				if (iph->daddr == ifa->ifa_address)
+				{
+					bAddrHit = true;
+					break;
+				}
+				i++;
+			}
+
+			in_dev_put(in_dev);
+
+			if (bAddrHit) {
+				port = ntohs(udph->dest);
+				dir = SVIP_NAT_STATS_REM2LOC;
+			} else
+				return 0;
+		} else
+#endif /* ! VLAN_8021Q_UNUSED */
+			return 0;
+		in_eth0 = 0;
+	} else if (real_dev == net_devs[SVIP_NET_DEV_VETH0_IDX]) {
+		/* check if packet arrived on veth0 */
+		port = ntohs(udph->source);
+		dir = SVIP_NAT_STATS_LOC2REM;
+	} else {
+		/* packet arrived neither on eth0, nor eth1, nor veth0 */
+		return 0;
+	}
+
+	/* calculate the respective index of the NAT table */
+	NAT_idx = SVIP_PORT_INDEX(port);
+	/* process the packet if a respective NAT rule exists */
+	nat_rule = &nat_table[NAT_idx].nat_rule;
+
+	if (nat_rule->typeIP != SVIP_IPV4_ADDR_TYPE) {
+		/* Rule check failed. IPv4 packet arrived, but IPv6 rule in
+		 * table.
+		 */
+		return 0;
+	}
+
+	ethh = (struct ethhdr *) skb_mac_header(skb);
+
+	/* copy packet's original source and destination IP addresses to use
+	 * later on to perform efficient checksum recalculation
+	 */
+	org_src_IP = iph->saddr;
+	org_ds_IP = iph->daddr;
+
+	if (dir == SVIP_NAT_STATS_REM2LOC) {
+		/* Process packet arrived on eth0 or eth1 */
+		u8 *dst_MAC;
+
+		if (iph->saddr != nat_rule->remIP.v4) {
+			/* Rule check failed. The packet is passed up the
+			 * layers, it will be dropped by UDP
+			 */
+			return 0;
+		}
+		dst_IP = &nat_rule->locIP.v4;
+		dst_MAC = nat_rule->locMAC;
+
+		/* determine weather the destination in on veth0 or on eth1 */
+		if ((*dst_IP & *pmask_veth0) == (*paddr_veth0 & *pmask_veth0)) {
+			/* veth0 */
+#ifndef VLAN_8021Q_UNUSED
+			if (vlan) {
+				struct net_device *vlan_dev;
+
+				rcu_read_lock();
+				vlan_dev = vlan_find_dev(
+					net_devs[SVIP_NET_DEV_VETH0_IDX],
+					vlan_proto, vid);
+				rcu_read_unlock();
+				if (vlan_dev) {
+					skb_push(skb, ETH_HLEN);
+					skb->dev = vlan_dev;
+				} else {
+					skb->dev = net_devs[
+					SVIP_NET_DEV_VETH0_IDX];
+					skb_push(skb, ETH_HLEN);
+				}
+			} else
+#endif /* ! VLAN_8021Q_UNUSED */
+			{
+				skb->dev = net_devs[SVIP_NET_DEV_VETH0_IDX];
+				skb_push(skb, ETH_HLEN);
+			}
+			src_IP = paddr_veth0;
+		} else {
+			/* eth1 */
+			if (!in_eth0)
+			{
+				/* came in on eth1 */
+				skb_push(skb, ETH_HLEN);
+			} else {
+				/* came in on eth0 */
+#ifndef VLAN_8021Q_UNUSED
+				if (vlan) {
+					struct net_device *vlan_dev;
+
+					rcu_read_lock();
+					vlan_dev = vlan_find_dev(
+						net_devs[SVIP_NET_DEV_ETH1_IDX],
+						vlan_proto, vid);
+					rcu_read_unlock();
+					if (vlan_dev) {
+						skb_push(skb, ETH_HLEN);
+						skb->dev = vlan_dev;
+					} else {
+						skb->dev = net_devs[
+						SVIP_NET_DEV_ETH1_IDX];
+						skb_push(skb, ETH_HLEN);
+					}
+				} else
+#endif /* ! VLAN_8021Q_UNUSED */
+				{
+					skb->dev = net_devs[SVIP_NET_DEV_ETH1_IDX];
+					skb_push(skb, ETH_HLEN);
+				}
+			}
+			src_IP = paddr_eth1;
+		}
+		iph->saddr = *src_IP;
+		memcpy((char *)ethh->h_source, (char *)skb->dev->dev_addr,
+			ETH_ALEN);
+		iph->daddr = *dst_IP;
+		memcpy((char *)ethh->h_dest, (char *)dst_MAC, ETH_ALEN);
+	} else {
+		/* Process packet arrived on veth0 */
+		if (iph->saddr != nat_rule->locIP.v4) {
+			/* Rule check failed. The packet is passed up
+			 * the layers, it will be dropped by UDP
+			 */
+			return 0;
+		}
+
+		/* determine weather the destination in on veth0 or eth0
+		 * or eth1 */
+		if ((nat_rule->remIP.v4 & *pmask_veth0)
+			== (*paddr_veth0 & *pmask_veth0)) {
+			/* veth0 */
+			src_IP = paddr_veth0;
+			skb_push(skb, ETH_HLEN);
+		} else if ((nat_rule->remIP.v4 & *pmask_eth1)
+			== (*paddr_eth1 & *pmask_eth1)) {
+			/* eth1 */
+#ifndef VLAN_8021Q_UNUSED
+			if (vlan) {
+				struct net_device *vlan_dev;
+
+				rcu_read_lock();
+				vlan_dev = vlan_find_dev(
+					net_devs[SVIP_NET_DEV_ETH1_IDX],
+					vlan_proto, vid);
+				rcu_read_unlock();
+				if (vlan_dev) {
+					unsigned int *pifa_addr;
+					skb_push(skb, ETH_HLEN);
+					skb->dev = vlan_dev;
+
+					get_ifaddr(skb->dev, &pifa_addr);
+					if (pifa_addr)
+						src_IP = pifa_addr;
+					else
+						src_IP = paddr_eth1;
+				} else {
+					skb->dev =
+						net_devs[SVIP_NET_DEV_ETH1_IDX];
+					src_IP = paddr_eth1;
+					skb_push(skb, ETH_HLEN);
+				}
+			} else
+#endif /* ! VLAN_8021Q_UNUSED */
+			{
+				skb->dev = net_devs[SVIP_NET_DEV_ETH1_IDX];
+				src_IP = paddr_eth1;
+				skb_push(skb, ETH_HLEN);
+			}
+		} else {
+			/* eth0 */
+#ifndef VLAN_8021Q_UNUSED
+			if (vlan) {
+				struct net_device *vlan_dev;
+
+				rcu_read_lock();
+				vlan_dev = vlan_find_dev(
+					net_devs[SVIP_NET_DEV_ETH0_IDX],
+					vlan_proto, vid);
+				rcu_read_unlock();
+				if (vlan_dev) {
+					unsigned int *pifa_addr;
+					skb_push(skb, ETH_HLEN);
+					skb->dev = vlan_dev;
+
+					get_ifaddr(skb->dev, &pifa_addr);
+					if (pifa_addr)
+						src_IP = pifa_addr;
+					else
+						src_IP = paddr_eth0;
+				} else {
+					skb->dev =
+						net_devs[SVIP_NET_DEV_ETH0_IDX];
+					src_IP = paddr_eth0;
+					skb_push(skb, ETH_HLEN);
+				}
+			} else
+#endif /* ! VLAN_8021Q_UNUSED */
+			{
+				skb->dev = net_devs[SVIP_NET_DEV_ETH0_IDX];
+				src_IP = paddr_eth0;
+				skb_push(skb, ETH_HLEN);
+			}
+		}
+		iph->saddr = *src_IP;
+		memcpy((char *)ethh->h_source, (char *)skb->dev->dev_addr,
+			ETH_ALEN);
+		iph->daddr = nat_rule->remIP.v4;
+		memcpy((char *)ethh->h_dest, (char *)nat_rule->remMAC,
+			ETH_ALEN);
+	}
+	nat_table[NAT_idx].nat_stats[dir].in_packets++;
+
+	iph->check = ip_udp_quick_csum(iph->check, (u16 *) &org_src_IP,
+		(u16 *) &iph->saddr, (u16 *) &org_ds_IP, (u16 *) &iph->daddr);
+	if (udph->check != 0) {
+		udph->check = ip_udp_quick_csum(udph->check,
+			(u16 *) &org_src_IP,
+			(u16 *) &iph->saddr, (u16 *) &org_ds_IP,
+			(u16 *) &iph->daddr);
+	}
+
+	/* write the packet out, directly to the network device */
+	if (dev_queue_xmit(skb) < 0)
+		nat_table[NAT_idx].nat_stats[dir].out_errors++;
+	else
+		nat_table[NAT_idx].nat_stats[dir].out_packets++;
+
+	return 1;
+}
+
+/******************************************************************************/
+/**
+ This function performs IPv6 NAT for received packets satisfying the
+ following requirements:
+
+ - packet is destined to local IP host
+ - transport protocol type is UDP
+ - destination UDP port is within range
+ - IPv6 NAT rule is defined for this UDP port
+
+ \arguments
+ skb - pointer to the receiving socket buffer
+
+ \return
+ returns 1 on performed SVIP NAT, else returns 0
+
+ \remarks
+ When function returns 0, it indicates the caller to pass the
+ packet up the IP stack to make further decision about it
+ */
+/******************************************************************************/
+int ipv6_do_SVIP_NAT(struct sk_buff *skb)
+{
+	struct net_device *real_dev;
+	struct ipv6hdr *iph;
+	struct udphdr *udph;
+	SVIP_NAT_IO_Rule_t *nat_rule;
+	int NAT_idx, in_eth0, dir;
+#ifndef VLAN_8021Q_UNUSED
+	int vlan;
+	unsigned short vid;
+	__be16 vlan_proto = 0;
+#endif /* ! VLAN_8021Q_UNUSED */
+	SVIP_UDP_PORT_t port;
+	struct in6_addr org_src_IP, org_ds_IP, *src_IP, *dst_IP;
+	struct ethhdr *ethh;
+	unsigned int ptr = 0;
+#ifdef CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK
+	int i = 0;
+#endif
+
+	/* do not consider if SVIP NAT device not open. */
+	if (!device_open)
+		return 0;
+
+	iph = ipv6_hdr(skb);
+	/* consider only UDP packets. */
+	if (ipv6_find_hdr(skb, &ptr, NEXTHDR_UDP, NULL, NULL) < 0)
+		return 0;
+
+#ifdef CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK
+	for (i = 0; i < nat_dest_IPv6_size; i++)
+		if (ipv6_addr_equal((struct in6_addr *) &iph->daddr,
+			(struct in6_addr *) &nat_dest_IPv6[i]))
+			break;
+	if (i >= nat_dest_IPv6_size)
+		return 0;
+#endif /* CONFIG_LTQ_SVIP_NAT_DESTIP_CHECK */
+
+	udph = (struct udphdr *) (skb->data + ptr);
+	/* consider only packets which UDP port numbers reside within
+	 * the predefined SVIP NAT UDP port range.
+	 */
+	if ((!SVIP_PORT_INRANGE(ntohs(udph->dest)))
+		&& (!SVIP_PORT_INRANGE(ntohs(udph->source))))
+		return 0;
+
+#ifndef VLAN_8021Q_UNUSED
+	/*
+	 * check if packet delivered over VLAN. VLAN packets will be routed over
+	 * the VLAN interfaces of the respective real Ethernet interface, if one
+	 * exists(VIDs must match). Else, the packet will be send out as IEEE
+	 * 802.3 Ethernet frame
+	 */
+	if (skb->dev->priv_flags & IFF_802_1Q_VLAN) {
+		vlan = 1;
+		vid = vlan_dev_vlan_id(skb->dev);
+		real_dev = vlan_dev_real_dev(skb->dev);
+		vlan_proto = skb->vlan_proto;
+	} else {
+		vlan = 0;
+		vid = 0;
+		real_dev = skb->dev;
+	}
+#endif /* ! VLAN_8021Q_UNUSED */
+
+#ifdef CONFIG_SVIP_FW_PKT_SNIFFER
+	/*
+	 * Debugging feature which can be enabled by writing,
+	 * 'echo 1 > /proc/net/svip_nat/snifferOnOff'.
+	 * It copies all packets received on veth0 and eth1 and, sends them out
+	 * over eth0. When a destination MAC address is specified through
+	 * /proc/net/svip_nat/snifferMAC, this MAC addess will substitute the
+	 * original MAC address of the packet.
+	 * It is recommended to specify a MAC address of some host where
+	 * Wireshark runs and sniffs for this traffic, else you may flood your
+	 * LAN with undeliverable traffic.
+	 * NOTE: In case of VLAN traffic the VLAN header information is lost.
+	 */
+	if (SVIP_NAT_sniffer) {
+		if (real_dev == net_devs[SVIP_NET_DEV_VETH0_IDX] ||
+			real_dev == net_devs[SVIP_NET_DEV_ETH1_IDX]) {
+			struct sk_buff *copied_skb;
+
+			/* gain the Ethernet header from the skb */
+			skb_push(skb, ETH_HLEN);
+
+			copied_skb = skb_copy(skb, GFP_ATOMIC);
+
+			if (SVIP_NAT_sniffer_MAC_set == 1) {
+				ethh = (struct ethhdr *)
+				skb_mac_header(copied_skb);
+				memcpy((char *)ethh->h_dest,
+					(char *)SVIP_NAT_sniffer_MAC,
+					ETH_ALEN);
+			}
+			copied_skb->dev = net_devs[SVIP_NET_DEV_ETH0_IDX];
+			dev_queue_xmit(copied_skb);
+
+			/* skip the ETH header again */
+			skb_pull(skb, ETH_HLEN);
+		}
+	}
+#endif
+
+	/* check if packet arrived on eth0 */
+	if (real_dev == net_devs[SVIP_NET_DEV_ETH0_IDX]) {
+		/*
+		 * Check if destination IP address equals IP address
+		 * of interface eth0. This is the case of packets originating
+		 * from a remote peer that are to be delivered to a channel
+		 * residing on THIS voice line card system. This is typical SVIP
+		 * NAT case, therefore this rule is placed on top.
+		 */
+		if (!ipv6_addr_cmp(&iph->daddr, paddr_eth0_ip6)) {
+			port = ntohs(udph->dest);
+			dir = SVIP_NAT_STATS_REM2LOC;
+		} else
+			return 0;
+		in_eth0 = 1;
+	/* check if packet arrived on eth1 */
+	} else if (real_dev == net_devs[SVIP_NET_DEV_ETH1_IDX]) {
+		if (!ipv6_addr_cmp(&iph->daddr, paddr_eth1_ip6)) {
+			port = ntohs(udph->dest);
+			dir = SVIP_NAT_STATS_REM2LOC;
+		} else
+			return 0;
+		in_eth0 = 0;
+	/* check if packet arrived on veth0 */
+	} else if (real_dev == net_devs[SVIP_NET_DEV_VETH0_IDX]) {
+		port = ntohs(udph->source);
+		dir = SVIP_NAT_STATS_LOC2REM;
+	} else
+		/* packet arrived neither on eth0, nor on eth1, nor on veth0 */
+		return 0;
+
+	/* calculate the respective index of the NAT table */
+	NAT_idx = SVIP_PORT_INDEX(port);
+	/* process the packet if a respective NAT rule exists */
+	nat_rule = &nat_table[NAT_idx].nat_rule;
+
+	if (nat_rule->typeIP != SVIP_IPV6_ADDR_TYPE)
+		/* Rule check failed. IPv6 packet arrived, but IPv4 rule in
+		 * table.
+		 */
+		return 0;
+
+	ethh = (struct ethhdr *) skb_mac_header(skb);
+
+	/* copy packet's original source and destination IP addresses to use
+	 * later on to perform efficient checksum recalculation
+	 */
+	org_src_IP = iph->saddr;
+	org_ds_IP = iph->daddr;
+
+	if (dir == SVIP_NAT_STATS_REM2LOC) {
+		/* Process packet arrived on eth0 or eth1 */
+		u8 *dst_MAC;
+
+		if (!ipv6_addr_equal((struct in6_addr *) &iph->saddr,
+			(struct in6_addr *) &nat_rule->remIP.v6)) {
+			/* Rule check failed. The packet is passed up the
+			 * layers, it will be dropped by UDP
+			 */
+			return 0;
+		}
+
+		dst_IP = (struct in6_addr *) &nat_rule->locIP.v6;
+		dst_MAC = nat_rule->locMAC;
+
+		/* determine weather the destination in on veth0 or on eth1 */
+		if (paddr_veth0_ip6 != NULL
+			&& ipv6_prefix_equal(dst_IP, paddr_veth0_ip6,
+			prefix_len_veth0)) {
+			/* veth0 */
+#ifndef VLAN_8021Q_UNUSED
+			if (vlan) {
+				struct net_device *vlan_dev;
+
+				rcu_read_lock();
+				vlan_dev = vlan_find_dev(
+					net_devs[SVIP_NET_DEV_VETH0_IDX],
+					vlan_proto,
+					vid);
+				rcu_read_unlock();
+				if (vlan_dev) {
+					skb_push(skb, ETH_HLEN);
+					skb->dev = vlan_dev;
+				} else {
+					skb->dev = net_devs[
+					SVIP_NET_DEV_VETH0_IDX];
+					skb_push(skb, ETH_HLEN);
+				}
+			} else
+#endif /* ! VLAN_8021Q_UNUSED */
+			{
+				skb->dev = net_devs[SVIP_NET_DEV_VETH0_IDX];
+				skb_push(skb, ETH_HLEN);
+			}
+			src_IP = paddr_veth0_ip6;
+		} else {
+			/* eth1 */
+			if (!in_eth0)
+			{
+				/* came in on eth1 */
+				skb_push(skb, ETH_HLEN);
+			} else {
+				/* came in on eth0 */
+#ifndef VLAN_8021Q_UNUSED
+				if (vlan) {
+					struct net_device *vlan_dev;
+
+					rcu_read_lock();
+					vlan_dev = vlan_find_dev(
+						net_devs[SVIP_NET_DEV_ETH1_IDX],
+						vlan_proto, vid);
+					rcu_read_unlock();
+					if (vlan_dev) {
+						skb_push(skb, ETH_HLEN);
+						skb->dev = vlan_dev;
+					} else {
+						skb->dev = net_devs[
+						SVIP_NET_DEV_ETH1_IDX];
+						skb_push(skb, ETH_HLEN);
+					}
+				} else
+#endif /* ! VLAN_8021Q_UNUSED */
+				{
+					skb->dev = net_devs[SVIP_NET_DEV_ETH1_IDX];
+					skb_push(skb, ETH_HLEN);
+				}
+			}
+			src_IP = paddr_eth1_ip6;
+		}
+		iph->saddr = *src_IP;
+		memcpy((char *)ethh->h_source, (char *)skb->dev->dev_addr,
+			ETH_ALEN);
+		iph->daddr = *dst_IP;
+		memcpy((char *)ethh->h_dest, (char *)dst_MAC, ETH_ALEN);
+	} else {
+		/* Process packet arrived on veth0 */
+		if (ipv6_addr_cmp((struct in6_addr *) &iph->saddr,
+			(struct in6_addr *) &nat_rule->locIP.v6)) {
+			/* Rule check failed. The packet is passed up the
+			 * layers, it will be dropped by UDP
+			 */
+			return 0;
+		}
+
+		/* determine weather the destination in on veth0 or eth0
+		 * or eth1 */
+		if (ipv6_prefix_equal((struct in6_addr *) &nat_rule->remIP.v6,
+			paddr_veth0_ip6, prefix_len_veth0)) {
+			/* veth0 */
+			src_IP = paddr_veth0_ip6;
+			skb_push(skb, ETH_HLEN);
+		} else if (ipv6_prefix_equal((struct in6_addr *) &nat_rule->remIP.v6,
+			paddr_eth0_ip6, prefix_len_eth0)) {
+			/* eth0 */
+#ifndef VLAN_8021Q_UNUSED
+			if (vlan) {
+				struct net_device *vlan_dev;
+
+				rcu_read_lock();
+				vlan_dev = vlan_find_dev(
+					net_devs[SVIP_NET_DEV_ETH0_IDX],
+					vlan_proto, vid);
+				rcu_read_unlock();
+				if (vlan_dev) {
+					struct in6_addr *pifa_addr;
+					skb_push(skb, ETH_HLEN);
+					skb->dev = vlan_dev;
+
+					get_inet6_ifaddr(skb->dev, &pifa_addr);
+					if (pifa_addr)
+						src_IP = pifa_addr;
+					else
+						src_IP = paddr_eth0_ip6;
+				} else {
+					skb->dev = net_devs[
+					SVIP_NET_DEV_ETH0_IDX];
+					src_IP = paddr_eth0_ip6;
+					skb_push(skb, ETH_HLEN);
+				}
+			} else
+#endif /* ! VLAN_8021Q_UNUSED */
+			{
+				skb->dev = net_devs[SVIP_NET_DEV_ETH0_IDX];
+				src_IP = paddr_eth0_ip6;
+				skb_push(skb, ETH_HLEN);
+			}
+		} else {
+			/* eth1 */
+#ifndef VLAN_8021Q_UNUSED
+			if (vlan) {
+				struct net_device *vlan_dev;
+
+				rcu_read_lock();
+				vlan_dev = vlan_find_dev(
+					net_devs[SVIP_NET_DEV_ETH1_IDX],
+					vlan_proto, vid);
+				rcu_read_unlock();
+				if (vlan_dev) {
+					struct in6_addr *pifa_addr;
+					skb_push(skb, ETH_HLEN);
+					skb->dev = vlan_dev;
+
+					get_inet6_ifaddr(skb->dev, &pifa_addr);
+					if (pifa_addr)
+						src_IP = pifa_addr;
+					else
+						src_IP = paddr_eth1_ip6;
+				} else {
+					skb->dev = net_devs[
+					SVIP_NET_DEV_ETH1_IDX];
+					src_IP = paddr_eth1_ip6;
+					skb_push(skb, ETH_HLEN);
+				}
+			} else
+#endif /* ! VLAN_8021Q_UNUSED */
+			{
+				skb->dev = net_devs[SVIP_NET_DEV_ETH1_IDX];
+				src_IP = paddr_eth1_ip6;
+				skb_push(skb, ETH_HLEN);
+			}
+		}
+		iph->saddr = *src_IP;
+		memcpy((char *)ethh->h_source, (char *)skb->dev->dev_addr,
+			ETH_ALEN);
+		memcpy(&iph->daddr, &nat_rule->remIP.v6,
+			sizeof(struct in6_addr));
+		memcpy((char *)ethh->h_dest, (char *)nat_rule->remMAC,
+			ETH_ALEN);
+	}
+	nat_table[NAT_idx].nat_stats[dir].in_packets++;
+
+	if (udph->check != 0) {
+		udph->check = ip6_udp_quick_csum(udph->check,
+			(u16 *) &org_src_IP,
+			(u16 *) &iph->saddr, (u16 *) &org_ds_IP,
+			(u16 *) &iph->daddr);
+	}
+
+	/* write the packet out, directly to the network device */
+	if (dev_queue_xmit(skb) < 0)
+		nat_table[NAT_idx].nat_stats[dir].out_errors++;
+	else
+		nat_table[NAT_idx].nat_stats[dir].out_packets++;
+
+	return 1;
+}
+
+/******************************************************************************/
+/**
+ Function executed upon unloading of the SVIP NAT module. It unregisters the
+ SVIP NAT configuration device and frees the memory used for the NAT table.
+
+ \remarks:
+ Currently the SVIP NAT module is statically linked into the Linux kernel
+ therefore this routine cannot be executed.
+ ******************************************************************************/
+static int __init init(void)
+{
+	int ret = 0;
+	struct net_device *dev;
+
+	if (misc_register(&SVIP_NAT_miscdev) != 0) {
+		pr_err("%s: cannot register SVIP NAT device node.\n",
+			SVIP_NAT_miscdev.name);
+		return -EIO;
+	}
+
+	/* allocation of memory for NAT table */
+	nat_table = kmalloc(sizeof(struct SVIP_NAT_table_entry) *
+		CONFIG_LTQ_SVIP_NAT_RULES_TOTAL,
+		GFP_ATOMIC);
+	if (nat_table == NULL) {
+		pr_err("SVIP NAT: Error(%d), allocating memory for NAT table\n",
+			ret);
+		return -1;
+	}
+
+	/* clear the NAT table */
+	memset((void *)nat_table, 0,
+		sizeof(struct SVIP_NAT_table_entry) *
+		CONFIG_LTQ_SVIP_NAT_RULES_TOTAL);
+
+	sem_nat_tbl_access = kmalloc(sizeof(struct semaphore), GFP_KERNEL);
+	if (sem_nat_tbl_access)
+		sema_init(sem_nat_tbl_access, 1);
+
+	SVIP_NAT_proc_install();
+
+	/* find pointers to 'struct net_device' of eth0 and veth0,
+	 * respectevely
+	 */
+	read_lock(&dev_base_lock);
+	for_each_netdev(&init_net, dev) {
+		if (!strcmp(dev->name, SVIP_NET_DEV_ETH0_NAME))
+			net_devs[SVIP_NET_DEV_ETH0_IDX] = dev;
+		if (!strcmp(dev->name, SVIP_NET_DEV_ETH1_NAME))
+			net_devs[SVIP_NET_DEV_ETH1_IDX] = dev;
+		else if (!strcmp(dev->name, SVIP_NET_DEV_VETH0_NAME))
+			net_devs[SVIP_NET_DEV_VETH0_IDX] = dev;
+	}
+	read_unlock(&dev_base_lock);
+
+	if (net_devs[SVIP_NET_DEV_ETH0_IDX] == NULL
+		|| net_devs[SVIP_NET_DEV_ETH1_IDX] == NULL
+		|| net_devs[SVIP_NET_DEV_VETH0_IDX] == NULL) {
+		pr_err("SVIP NAT: Error, unable to locate eth0 or eth1 or veth0 interfaces\n");
+		return -1;
+	}
+
+	pr_info("%s, (c) 2014, Lantiq Deutschland GmbH\n",
+		&SVIP_NAT_INFO_STR[4]);
+
+	return ret;
+}
+
+/******************************************************************************/
+/**
+ Function executed upon unloading of the SVIP NAT module. It unregisters the
+ SVIP NAT configuration device and frees the memory used for the NAT table.
+
+ \remarks:
+ Currently the SVIP NAT module is statically linked into the Linux kernel
+ therefore this routine cannot be executed.
+ ******************************************************************************/
+static void __exit fini(void)
+{
+	/* unregister SVIP NAT configuration device */
+	misc_deregister(&SVIP_NAT_miscdev);
+
+	/* release memory of SVIP NAT table */
+	if (nat_table != NULL)
+		kfree(nat_table);
+}
+
+module_init(init);
+module_exit(fini);
--- a/net/ipv6/ip6_input.c
+++ b/net/ipv6/ip6_input.c
@@ -29,6 +29,9 @@
 #include <linux/icmpv6.h>
 #include <linux/mroute6.h>
 #include <linux/slab.h>
+#ifdef CONFIG_LTQ_SVIP_NAT
+#include <linux/svip_nat.h>
+#endif
 
 #include <linux/netfilter.h>
 #include <linux/netfilter_ipv6.h>
@@ -200,6 +203,13 @@ int ipv6_rcv(struct sk_buff *skb, struct
 	/* Must drop socket now because of tproxy. */
 	skb_orphan(skb);
 
+#ifdef CONFIG_LTQ_SVIP_NAT
+	if (ipv6_do_SVIP_NAT(skb)) {
+		/* SVIP NAT performed, receiving successful */
+		return NET_RX_SUCCESS;
+	}
+#endif
+
 	return NF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING,
 		       net, NULL, skb, dev, NULL,
 		       ip6_rcv_finish);
